<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <TITLE>Jena I/O Mini HowTo</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../javadoc/stylesheet.css" TITLE="Style">
  </HEAD>
  <BODY>
  <h1>Jena I/O Mini HowTo</h1>
<p>
This is a guide to the I/O subsystem of Jena.
It has some obligatory reading for all Jena users migrating
from Jena1 to Jena2. The bulk of the document is aimed
at users wishing to use advanced features within the I/O
subsystem.
</p>
<p>The N3 subsystem is not explored in detail.</p>
<h2>Contents</h2>
<ul>
<li><a href="#rush">1. Rush Guide - Jena1 Migration (Must Read)</a>
<ul>
<li><a href="#rdfxml">1.1 RDF/XML, RDF/XML-ABBREV</a>
</li>
<li><a href="#n3">1.2 N3</a>
</li>
<li><a href="#ntriple">1.2 N-TRIPLE</a>
</li>
</ul>
<li><a href="#encoding">2. Character Encoding in Java and XML</a></li>
<li><a href="#reader-writer">3. When to Use Reader and Writer?</a></li>
<li><a href="#intro-advanced">4. Introduction to Advanced Jena I/O</a></li>
<li><a href="#input">5. Advanced RDF/XML Input</a>
<ul><li><a href="#arp-properties">
5.1 ARP properties</a></li></ul></li>
<li><a href="#output">6. Advanced RDF/XML Output</a></li>
<li><a href="#conformance">7. Conformance</a></li>
<li><a href="#speed">8. Faster RDF/XML I/O</a></li>

</ul>
<h2><a name="rush">1. Rush Guide - Jena1 Migration (Must Read)</a></h2>
<p>Jena2 I/O subsystem uses InputStream's and OutputStream's where
Jena1 used Reader's and Writer's.</p>
<p>
The main I/O methods to use in Jena
 are found on the 
<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A>
interface. These are:
</p>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#read(java.io.InputStream, java.lang.String)">read</A></B>(java.io.InputStream&nbsp;in,
     java.lang.String&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add statements from an RDF/XML serialization</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#read(java.io.InputStream, java.lang.String, java.lang.String)">read</A></B>(java.io.InputStream&nbsp;in,
     java.lang.String&nbsp;base,
     java.lang.String&nbsp;lang)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add RDF statements represented in language <code>lang</code> to the model.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#read(java.lang.String)">read</A></B>(java.lang.String&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add the RDF statements from an XML document.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#write(java.io.OutputStream)">write</A></B>(java.io.OutputStream&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write the model as an XML document.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#write(java.io.OutputStream, java.lang.String)">write</A></B>(java.io.OutputStream&nbsp;out,
      java.lang.String&nbsp;lang)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write a serialized represention of a model in a specified language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#write(java.io.OutputStream, java.lang.String, java.lang.String)">write</A></B>(java.io.OutputStream&nbsp;out,
      java.lang.String&nbsp;lang,
      java.lang.String&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write a serialized represention of a model in a specified language.</TD>
</TR>
</TABLE>
<p>The built-in languages are 
<code>"RDF/XML"</code>,
<code>"RDF/XML-ABBREV"</code>,
<code>"N-TRIPLE"</code> and
<code>"N3"</code>.
</p>
<p>The Jena1 developer will note that all but one of these methods 
are new
 in Jena2. Jena1 mistakenly required the use of java.io.Reader
and java.io.Writer. While these classes work well on a single machine,
the way they address character encoding problems differs significantly
from the solution offered by XML. 
A typical use of the Jena1 
input interface such as 
<code><b>mdl.read(new&nbsp;FileReader(fName));</b></code>
is incorrect, and will give the wrong results
if the file contains non-ASCII data.
Also, in Jena1, <code><b>mdl.write(new&nbsp;FileWriter(fName));</b></code>
wrote incorrect XML for non-ASCII data (now fixed). 
However, these two
bugs in Jena1  canceled each other out, as long
as the system doing the reading had the same default
character encoding as the one doing the writing, which is why
it did not bite in a typical development environment.
There is the substantial migration task when porting
Jena1 code to Jena2 code of reviewing all the I/O calls
and changing them to use InputStream's and OutputStream's.
</p>
<p>The old methods are still in the interface,
and are not deprecated. They are useful, see
<a href="#reader-writer">below</a>; and there
is every intention to continue to support them.
However, the RDF/XML parser now checks to see
if the 
<code><b>Model.read(Reader &hellip;)</b></code> 
calls are being abused,
and issues
<CODE><B>
<A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARPErrorNumbers.html#ERR_ENCODING_MISMATCH">ERR_ENCODING_MISMATCH</A></B></CODE>
and
<CODE><B>
<A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARPErrorNumbers.html#WARN_ENCODING_MISMATCH">WARN_ENCODING_MISMATCH</A></B></CODE>
errors. A naive Jena1 to Jena2 port will almost certainly
result in such errors.
This reflects code that had bugs in Jena1, which would
exhibit themselves by misreading certain (non-ASCII) input files.
The old output routines 
<code><b>Model.write(Writer &hellip;)</b></code> 
 are not suitable
for N3, except as indicated 
<a href="#reader-writer">below</a>. With RDF/XML by default
they produce correct XML by using an appropriate XML declaration
giving the encoding - e.g. 
<code>&lt?xml&nbsp;version='1.0'&nbsp;encoding='ISO-8859-15'?></code> 
on my system.
However, such XML is less portable than XML in UTF-8.
Using the 
<code><b>Model.write(OutputStream &hellip;)</b></code> 
methods allows the Jena system code to choose UTF-8 encoding,
which is the best choice.
</p>
<h3><a name="rdfxml">1.1 RDF/XML, RDF/XML-ABBREV</a></h3>
<p>
For input, both of these are the same, and fully implement
the 
<a href="http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20030123/">
RDF Syntax Last Call Working Draft</a>, see 
<a href="#conformance">conformance</a>.
</p>
<p>
For output, <code>"RDF/XML"</code>, produces regular output reasonably
efficiently, but it is not readable.
In contrast, <code>"RDF/XML-ABBREV"</code>, produces readable output 
without much regard to efficiency.
</p>
<p>All the readers and writers for RDF/XML are 
configurable, see below,
<a href="#input">input</a> and <a href="#output">output</a>.</p>
<h3><a name="n3">1.2 N3</a></h3>
<p>The N3 readers and writers implement 
<a href=
"http://www.w3.org/2000/10/swap/Primer.html">Tim Berners-Lee's N3</a> language.
They are not configurable.
</p>
<h3><a name="ntriple">1.3 N-TRIPLE</a></h3>
<p>The N-TRIPLE readers and writers implement 
<a href=
"http://www.w3.org/TR/2003/WD-rdf-testcases-20030123/#ntriples">RDF Core's
N-Triples</a> language. They are not configurable.</p>

<h2><a name="encoding">2. Character Encoding in Java and XML</a></h2>
<p>
What when wrong with character encoding?
</p>
<p>
The java.io.* classes based around Reader's and Writer's
 are intended to help us avoid
encoding problems.
The encoding attribute in the XML declaration
at the top of an XML document is intended to help us avoid
encoding problems.
Unfortunately, these are two different approaches; and Jena1 went with
the Java conventions, whereas the 
Web scalable conventions are those used by XML.

</p>
<p>The Java approach is that the machine on which the Java is
running has some default encoding. I/O done with FileReader's and
PrintWriter's etc, then is done using that encoding, unless there
is a specific user instruction when the Reader or Writer is created.
It is not possible to change the encoding used by a Reader or Writer
while it is being used.
</p>
<p>
The XML approach is that XML documents are in UTF-8 or UTF-16
unless they say otherwise in the first line of the document
(this first line is sufficiently restricted to make it possible
to read it without knowing the encoding).
Hence, an XML reader should start by looking at the first few bytes
and work out from those whether it is UTF-8 UTF-16 or some
other encoding as declared in the first line. From then on,
it uses that encoding.</p>
<p>The Java approach is designed for ease of use on a single
machine, which uses a single encoding; often being a one-byte
encoding, e.g. for European languages which do not need thousands
of different characters.</p>
<p>The XML approach is designed for the Web which uses
multiple encodings, and some of them requiring thousands
of characters.</p>
<p>In Jena1, we had not understood these issues; and went with
the Java solution. This was the wrong call. We have now
fixed it. We are sorry that this does cause our users
work when migrating to Jena2.
</p>

<h2><a name="reader-writer">3. When to Use Reader and Writer?</a></h2>
<p>
Infrequently.
</p>
<p>
Despite these problems it is still sometimes appropriate
to use Readers and Writers with Jena I/O.
A good example is using Readers and Writers into StringBuffers
in memory. These do not need to be encoded and decoded so a character
encoding does not need to be specified.
Other examples are when an advanced user explicitly wishes to
correctly control the encoding.
</p>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#read(java.io.Reader, java.lang.String)">read</A></B>(java.io.Reader&nbsp;reader,
     java.lang.String&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using this method is often a mistake.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#read(java.io.Reader, java.lang.String, java.lang.String)">read</A></B>(java.io.Reader&nbsp;reader,
     java.lang.String&nbsp;base,
     java.lang.String&nbsp;lang)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using this method is often a mistake.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#write(java.io.Writer)">write</A></B>(java.io.Writer&nbsp;writer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Caution! Write the model as an XML document.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#write(java.io.Writer, java.lang.String)">write</A></B>(java.io.Writer&nbsp;writer,
      java.lang.String&nbsp;lang)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Caution! Write a serialized represention of a model in a specified language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html">Model</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/Model.html#write(java.io.Writer, java.lang.String, java.lang.String)">write</A></B>(java.io.Writer&nbsp;writer,
      java.lang.String&nbsp;lang,
      java.lang.String&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Caution! Write a serialized represention of a model in a specified language.</TD>
</TR>
</TABLE>
<p>
Incorrect use of these 
<code><b>read(Reader,&nbsp;&hellip;)</b></code> methods results in warnings and errors with RDF/XML and RDF/XML-ABBREV
(except in a few cases where the incorrect use cannot be automatically detected).
Incorrect use of the  
<code><b>write(Writer,&nbsp;&hellip;)</b></code> methods results in
peculiar XML declarations such as <code>%lt?xml version="1.0" encoding="WINDOWS-1252"?></code>.
This would reflect that the character encoding you used (probably without realizing)
 in your Writer is registered with IANA under the name "WINDOWS-1252".
The resulting XML is of 
reduced portability
 as a result. Glenn Marcy <a href="http://nagoya.apache.org/bugzilla/show_bug.cgi?id=4456">notes</a>:
</p>
<quote>
since UTF-8 and 
UTF-16 are the only encodings REQUIRED to be understood by all conformant XML 
processors, even ISO-8859-1 would technically be on shaky ground if not for the 
fact that it is in such widespread use that every reasonable XML processor 
supports it.
</quote>
<p>
With N-TRIPLE incorrect use is usually benign, since N-TRIPLE is ascii based.
</p>
<p>
Character encoding issues of N3 are not well-defined; hence use of these methods
may require changes in the future. Use of the InputStream and OutputStream methods
will allow your code to work with future versions of Jena which do the right thing -
whatever that is. Currently the OutputStream methods use UTF-8 encoding.
</p>
<h2><a name="intro-advanced">4. Introduction to Advanced Jena I/O</a></h2>
<p>
The RDF/XML input and output is configurable.
</p>
<p>
However, to configure it, it is necessary to access an RDFReader
or RDFWriter object that remains hidden in the
simpler interface above.
</p>
<p>The four vital calls in the Model interface are:
</p><TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFReader.html">RDFReader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFReaderF.html#getReader()">getReader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return an RDFReader instance for the default serialization language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFReader.html">RDFReader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFReaderF.html#getReader(java.lang.String)">getReader</A></B>(java.lang.String&nbsp;lang)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return an RDFReader instance for the specified serialization language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFWriter.html">RDFWriter</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFWriterF.html#getWriter()">getWriter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return an RDFWriter instance for the default serialization language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFWriter.html">RDFWriter</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFWriterF.html#getWriter(java.lang.String)">getWriter</A></B>(java.lang.String&nbsp;lang)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an RDFWriter instance for the specified serialization language.</TD>
</TR>
</TABLE>
<p>
Each of these calls returns an RDFReader or RDFWriter that can
be used to read or write any Model (not just the one
which created it).
As well as the necessary 
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFReader.html#read(com.hp.hpl.jena.rdf.model.Model, java.io.InputStream, java.lang.String)">read</A></B></CODE>
and
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFWriter.html#write(com.hp.hpl.jena.rdf.model.Model, java.io.OutputStream, java.lang.String)">write</A></B></CODE>
methods, these interfaces provide:

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFErrorHandler.html">RDFErrorHandler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFReader.html#setErrorHandler(com.hp.hpl.jena.rdf.model.RDFErrorHandler)">setErrorHandler</A></B>(<A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFErrorHandler.html">RDFErrorHandler</A>&nbsp;errHandler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set an error handler for the reader</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFReader.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(java.lang.String&nbsp;propName,
            java.lang.Object&nbsp;propValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the value of a reader property.</TD>
</TR>
</TABLE>
<p>Setting properties, or the error handler, on an RDFReader or an RDFWriter
allows the programmer to access non-default behaviour.
Moreover, since the RDFReader and RDFWriter is not bound to a specific
Model, a typical idiom is to create the RDFReader or RDFWriter
on system initialization, to set the appropriate properties
so that it behaves exactly as required in your system, and
then to do all subsequent I/O through it.
</p>
<pre>
    Model m = new ModelMem();
    RDFWriter writer = m.getRDFWriter();
    m = null; // m is no longer needed.
    writer.setErrorHandler(myErrorHandler);
    writer.setProperty("showXmlDeclaration","true");
    writer.setProperty("tab","8");
    writer.setProperty("relativeURIs","same-document,relative");
    &hellip;
    Model marray[];
    &hellip;
    for (int i=0; i&lt;marray.length; i++) {
    &hellip;
        OutputStream out = new FileOutputStream("foo" + i + ".rdf");
        writer.write(marray[i],
                           out,
          "http://example.org/");
        out.close();
    }
</pre>
<p>
Note that all of the current implementations are
synchronized, so that a specific RDFReader cannot be
reading two different documents at the same time. In
a multihtreaded application this may suggest a need
for a pool of RDFReaders and/or RDFWriters, or
alternatively to create, initialize, use and discard them as needed.
</p>
<p>
For the languages N3 and N-TRIPLE there are currently
no properties supported for neither the RDFReader nor
the RDFWriter. Hence this idiom above is not very helpful,
and just using the Model.write() methods may prove easier.
</p>
<p>
For RDF/XML and RDF/XML-ABBREV there are many options
in both the RDFReader and the RDFWriter.
These options are detailed in the javadoc for

<CODE><B>JenaReader.<A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/JenaReader.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(String,&nbsp;Object)</CODE>
and
<CODE><B>RDFXMLWriterI.<A HREF="../../javadoc/com/hp/hpl/jena/xmloutput/RDFXMLWriterI.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(String,&nbsp;Object)</CODE>
, and they are also given below.
</p>
<h2><a name="input">5. Advanced RDF/XML Input</a></h2>
<p>
For access to these advanced features, first
get an RDFReader object that is an instance of
an ARP parser, by using the
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFReaderF.html#getReader()">getReader</A></B>()</CODE>
method on any Model.
It is then configured using the
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/JenaReader.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(String,&nbsp;Object)</CODE>
method.
This
changes the properties for parsing RDF/XML.
Many of the properties change the RDF parser, some change the XML parser.
(The Jena RDF/XML parser, ARP, is built using a fairly direct implementation
of the 
<a href="http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20030123/#section-Infoset-Grammar">
RDF grammar</a> over a 
<a href="http://xml.apache.org/xerces2-j/index.html">Xerces2-J</a> XML parser).
However, changing the features and properties of the XML parser
 is not likely to be useful, but weas easy to implement.
</p>
<p>
 This method is not tested in the standard Jena test suite.
</p>
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/JenaReader.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(String,&nbsp;Object)</CODE>
 can be used to set and get:
 <dl>
 <dt>
 ARP properties
 </dt>
 <dd>
These allow fine grain control over the extensive error reporting capabailities
of ARP. And are detailed directly below.
 </dd>
 <dt>
 SAX2 features</dt>
 <dd>
 See <a href="http://xml.apache.org/xerces2-j/features.html">Xerces features</a>.
 Value should be given as a String "true" or "false" or a Boolean.
 </dd>
 <dt>
 SAX2 properties
 </dt>
 <dd>
 See <a href="http://xml.apache.org/xerces2-j/properties.html">Xerces properties</a>.
 </dd>
 <dt>
 Xerces features
 </dt>
 <dd>
 See <a href="http://xml.apache.org/xerces2-j/features.html">Xerces features</a>.
 Value should be given as a String "true" or "false" or a Boolean.
 </dd>
 <dt>
 Xerces properties
 </dt>
 <dd>
 See <a href="http://xml.apache.org/xerces2-j/properties.html">Xerces properties</a>.
 </dd>
</dl>
<h3><a name="arp-properties">
5.1 ARP properties</a></h3>
 <p>
An ARP property is
 referred to either by its property name, (see below) or by
 an absolute URL of the form <code>http://jena.hpl.hp.com/arp/properties/&lt;PropertyName&gt;</code>.
 The value should be a String, an Integer or a Boolean depending on the property.
 <p>
 ARP property names and string values are case insensitive.
 </p>
 <TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0">
 <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 <TD COLSPAN=4><FONT SIZE="+2">
 <B>ARP Properties</B></FONT></TD>
 </TR>
 <tr BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
 <th>Property Name</th>
 <th>Description</th>
 <th>Value class</th>
 <th>Legal Values</th>
 </tr>
 <tr BGCOLOR="white" CLASS="TableRowColor">
 <td><CODE>error-mode</CODE></td>
 <td>
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARP.html#setDefaultErrorMode()"><CODE>ARP.setDefaultErrorMode()</CODE></A><br>
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARP.html#setLaxErrorMode()"><CODE>ARP.setLaxErrorMode()</CODE></A><br>
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARP.html#setStrictErrorMode()"><CODE>ARP.setStrictErrorMode()</CODE></A><br>
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARP.html#setStrictErrorMode(int)"><CODE>ARP.setStrictErrorMode(int)</CODE></A><br>
This allows a coarse-grained approach to control of error handling.
Setting this property is equivalent to setting many of the fine-grained error handling
properties.
 </td>
 <td>String</td>
 <td><CODE>default</CODE><br>
 <CODE>lax</CODE><br>
 <CODE>strict</CODE><br>
 <CODE>strict-ignore</CODE><br>
 <CODE>strict-warning</CODE><br>
 <CODE>strict-error</CODE><br>
 <CODE>strict-fatal</CODE><br></td>
 </tr>
 <tr BGCOLOR="white" CLASS="TableRowColor">
 <td><CODE>embedding</CODE></td>
 <td>
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARP.html#setEmbedding(boolean)"><CODE>ARP.setEmbedding(boolean)</CODE></A><br/>
This sets ARP to look for RDF embedded within an enclosing XML document.
 </td>
 <td>String or Boolean</td>
 <td><CODE>true</CODE> or <CODE>false</CODE></td>
 </tr>
 <tr BGCOLOR="white" CLASS="TableRowColor">
 <td>
 <code>ERR_&lt;XXX&gt;</code><br>
 <code>WARN_&lt;XXX&gt;</code><br>
 <code>IGN_&lt;XXX&gt;</code></td>
 <td>
See
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARPErrorNumbers.html"><CODE>ARPErrorNumbers</CODE></A>
for a complete list
of the error conditions detected.<br>
Setting one of these properties is equivalent to the method
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARP.html#setErrorMode(int, int)"><CODE>ARP.setErrorMode(int, int)</CODE></A>.
Thus fine-grained control over the behaviour in response to specific error conditions
is possible.
 </td>
 <td>String or Integer</td>
 <td><A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARPErrorNumbers.html#EM_IGNORE"><CODE>EM_IGNORE</CODE></A><br>
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARPErrorNumbers.html#EM_WARNING"><CODE>EM_WARNING</CODE></A><br>
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARPErrorNumbers.html#EM_ERROR"><CODE>EM_ERROR</CODE></A><br>
 <A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARPErrorNumbers.html#EM_FATAL"><CODE>EM_FATAL</CODE></A><br>
 </td>
 </tr>
 </table>
<p>
As an example, if you are working in an environment with legacy RDF data that
uses unqualified RDF attributes such as "about" instead of "rdf:about", then
the following code is appropriate:
</p>

<pre>
    Model m = new ModelMem();
    RDFReader arp = m.getRDFReader();
    m = null; // m is no longer needed.
    // initialize arp
    // Do not warn on use of unqualified RDF attributes.
    arp.setProperty("WARN_UNQUALIFIED_RDF_ATTRIBUTE","EM_IGNORE");

    &hellip;
        InputStream in = new FileInputStream(fname);
        arp.read(m,in,url);
        in.close();
</pre>
<p>As a second example, suppose you wish to work in strict mode,
but allow <code>"daml:collection"</code>, the following works:
</p>
 
<pre>
     &hellip;
     arp.setProperty("error-mode", "strict" );
     arp.setProperty("IGN_DAML_COLLECTION","EM_IGNORE");
     &hellip;
</pre>
<p>The other way round does not work.
</p>
<pre>
     &hellip;
     arp.setProperty("IGN_DAML_COLLECTION","EM_IGNORE");
     arp.setProperty("error-mode", "strict" );
     &hellip;
</pre>
<p>This is because in strict mode 
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/ARPErrorNumbers.html#IGN_DAML_COLLECTION">IGN_DAML_COLLECTION</A></B></CODE>
is treated as an error, and so the second call to setProperty overwrites the effect of
the first.
</p>
<h2><a name="output">6. Advanced RDF/XML Output</a></h2>
<p>
The first RDF/XML output question is whether to use
the <code>"RDF/XML"</code> or <code>RDF/XML-ABBREV</code>
writer. While some of the code is shared,
this two writers are really very different, resulting
in different but equivalent output. <code>RDF/XML-ABBREV</code>
is slower, but should produce more readable XML.
</p>
<p>
For access to advanced features, first
get an RDFWriter object, of the appropriate language, by using 
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFWriterF.html#getWriter(java.lang.String)">getWriter</A></B>("RDF/XML")</CODE>
or
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/model/RDFWriterF.html#getWriter(java.lang.String)">getWriter</A></B>("RDF/XML-ABBREV")</CODE>
on any Model.
It is then configured using the
<CODE><B><A HREF="../../javadoc/com/hp/hpl/jena/rdf/arp/JenaReader.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(String,&nbsp;Object)</CODE>
method.
This
changes the properties for writing RDF/XML.
</p>
  <TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0">
  <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
  <TD COLSPAN=4><FONT SIZE="+2">
  <B>Properties to Control RDF/XML Output</B></FONT></TD>
  </TR>
  <tr BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
  <th>Property Name</th>
  <th>Description</th>
  <th>Value class</th>
  <th>Legal Values</th>
  </tr>
  <tr BGCOLOR="white" CLASS="TableRowColor">
 <td>xmlbase</td>
 <td>The value for xml:base in the
  file as a string.</td><td>String</td>
 <td>a URI string, or null (default)</td></tr>
  <tr BGCOLOR="white" CLASS="TableRowColor">
  <td>longId</td>
  <td> Whether to use long or short id's for anon
  resources. Short id's are easier to read and are the default, but can run
  out of memory on very large models.</td>
 <td>String or Boolean</td>
 <td>
 "true",  "false" (default)
  </td>
 </tr>
  <tr BGCOLOR="white" CLASS="TableRowColor">
  <td>allowBadURIs</td>
  <td>URIs in the graph are, by default, checked prior to
 serialization.</td>
 <td>String or Boolean</td>
 <td>
 "true",  "false" (default)
  </td>
 </tr>
  <tr BGCOLOR="white" CLASS="TableRowColor">
  <td>relativeURIs</td>
 <td>
 What sort of relative URIs should be used.
 A comma separate list of options:
     <dl>
     <dt>same-document
     <dd>same-document references (e.g. "" or "#foo")
     <dt>network
     <dd>network paths e.g. "//example.org/foo" omitting the URI scheme
     <dt>absolute
     <dd>absolute paths e.g. "/foo" omitting the scheme and authority
     <dt>relative
     <dd>relative path not begining in "../"
     <dt>parent
     <dd>relative path begining in "../"
     <dt>grandparent
     <dd>relative path begining in "../../"
     </dl>
 The default value is "same-document, absolute, relative, parent".
 To switch off relative URIs use the value "".
     Relative    URIs of any of these types are output where possible if
  and only if the option has been specified.
 </td>
 <td>String</td>
 <td></td>
 </tr>
   <tr BGCOLOR="white" CLASS="TableRowColor">
  <td>showXmlDeclaration</td>
  <dd>can be true, false or "default" (null)
  <td>If true, an XML Declaration is included in the output, if false
   no XML declaration is included.
   The default behaviour only gives an XML Declaration when
   asked to write to an OutputStreamWriter that uses some
   encoding other than UTF-8 or UTF-16. 
 In this case the encoding is shown
   in the XML declaration.
 To ensure that the encoding attribute is shown in the XML declaration
 either use the <code><b>write(Model,Writer,String)</b></code>
 variant with an appropriate OutputStreamWriter or set this option
 to false write the declaration to an OutputStream before calling
 <code><b>write(Model,OutputStream,String)</b></code>.
 </td>
 <td>true, "true", false, "false" or "default"</td>
 </tr>
   <tr BGCOLOR="white" CLASS="TableRowColor">
  <td>tab</td>
  <td>The number of spaces with which to indent XML child elements.</td>
 <td>String or Integer</td>
 <td>positive integer "2" is the default</td>
 </tr>
   <tr BGCOLOR="white" CLASS="TableRowColor">
  <td>attributeQuoteChar</td>
 <td>How to write XML attributes.</td>
 <td>String</td>
 <td>"\"" or "'"</td>
 </tr>
   <tr BGCOLOR="white" CLASS="TableRowColor">
  <td>blockRules</td>
  <td>
  A list of Resource or a String being a comma separated list
  of fragment
  IDs from
  <a href="http://www.w3.org/TR/rdf-syntax-grammar">
  http://www.w3.org/TR/rdf-syntax-grammar</a> indicating
  grammar rules that will not be used.
  Rules that can be avoided are:
  <ul>
  <li><a href="http://www.w3.org/TR/rdf-syntax-grammar#section-Reification"
  >section-Reification</a>  (<A HREF="../../javadoc/com/hp/hpl/jena/vocabulary/RDFSyntax.html#sectionReification"><CODE>RDFSyntax.sectionReification</CODE></A>)</li>
  <li><a href="http://www.w3.org/TR/rdf-syntax-grammar#section-List-Expand"
  >section-List-Expand</a> (<A HREF="../../javadoc/com/hp/hpl/jena/vocabulary/RDFSyntax.html#sectionListExpand"><CODE>RDFSyntax.sectionListExpand</CODE></A>)</li>
  <li><a href="http://www.w3.org/TR/rdf-syntax-grammar#parseTypeLiteralPropertyElt">parseTypeLiteralPropertyElt</a>
  (<A HREF="../../javadoc/com/hp/hpl/jena/vocabulary/RDFSyntax.html#parseTypeLiteralPropertyElt"><CODE>RDFSyntax.parseTypeLiteralPropertyElt</CODE></A>)</li>
  <li><a href="http://www.w3.org/TR/rdf-syntax-grammar#parseTypeResourcePropertyElt">parseTypeResourcePropertyElt</a>
  (<A HREF="../../javadoc/com/hp/hpl/jena/vocabulary/RDFSyntax.html#parseTypeLiteralPropertyElt"><CODE>RDFSyntax.parseTypeLiteralPropertyElt</CODE></A>)</li>
  <li><a href="http://www.w3.org/TR/rdf-syntax-grammar#parseTypeCollectionPropertyElt">parseTypeCollectionPropertyElt</a>
  (<A HREF="../../javadoc/com/hp/hpl/jena/vocabulary/RDFSyntax.html#parseTypeCollectionPropertyElt"><CODE>RDFSyntax.parseTypeCollectionPropertyElt</CODE></A>)</li>
  <li><a href="http://www.w3.org/TR/rdf-syntax-grammar#idAttr">idAttr</a>
  (<A HREF="../../javadoc/com/hp/hpl/jena/vocabulary/RDFSyntax.html#idAttr"><CODE>RDFSyntax.idAttr</CODE></A>)</li>
  <li><a href="http://www.w3.org/TR/rdf-syntax-grammar#propertyAttr">propertyAttr</a>
  (<A HREF="../../javadoc/com/hp/hpl/jena/vocabulary/RDFSyntax.html#propertyAttr"><CODE>RDFSyntax.propertyAttr</CODE></A>)</li>
  </ul>
  In addition "daml:collection" (<A HREF="../../javadoc/com/hp/hpl/jena/vocabulary/DAML_OIL.html#collection"><CODE>DAML_OIL.collection</CODE></A>)
  can be blocked. Blocking <a href=
  "http://www.w3.org/TR/rdf-syntax-grammar#idAttr">idAttr</a>  also blocks
  <a href="http://www.w3.org/TR/rdf-syntax-grammar#section-Reification"
  >section-Reification</a>.
  For the basic writer (RDF/XML) only
  <a href="http://www.w3.org/TR/rdf-syntax-grammar#parseTypeLiteralPropertyElt">parseTypeLiteralPropertyElt</a>
  has any affect, since none of the other rules are implemented by that writer.
 </td><td>Resource[] or String</td><td></td>
  
  <tr BGCOLOR="white" CLASS="TableRowColor">
  <td>prettyTypes</td>
  <td>Only for the RDF/XML-ABBREV writer.
 This a list of
  the types of the principal objects in the model.  The writer
   will tend to create RDF/XML with resources of these types at the
   top level.
  <br />
  Example usage showing the default value:
   <pre>
  w.setProperty("prettyTypes",
           new Resource[]{
                DAML_OIL.Ontology,
                DAML_OIL.Class,
                DAML_OIL.Datatype,
                DAML_OIL.Property,
                DAML_OIL.ObjectProperty,
                DAML_OIL.DatatypeProperty,
                DAML_OIL.TransitiveProperty,
                DAML_OIL.UnambigousProperty,
                DAML_OIL.UniqueProperty,
                });
   </pre>
   </td><td>Resource[]</td><td></td>
 </tr>
 </table>

<p>
As an example,
</p>
<pre>
     RDFWriter w = m.getWriter("RDF/XML-ABBREV");
     w.setProperty("attribtueQuoteChar","'");
     w.setProperty("showXMLDeclaration","true");
     w.setProperty("tab","1");
     w.setProperty("blockRules",
       "daml:collection,parseTypeLiteralPropertyElt,"
       +"parseTypeResourcePropertyElt,parseTypeCollectionPropertyElt");
</pre>
<p>creates a writer that does not use rdf:parseType (preferring rdf:datatype for 
rdf:XMLLiteral), indents only a little, and produces the XMLDeclaration. Attributes
are used, and are quoted with "'".</p>

<h2><a name="conformance">7. Conformance</a></h2>
<p>The RDF/XML I/O endeavours to conform with the 
<a href="http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20030123/">
RDF Syntax Last Call Working Draft</a>.</p>
<p>The parser must be set to strict mode, in which case
it's only non-conformant behaviour is that it treats
<code>rdf:parseType="daml:collection"</code> as an error.
(The conformant behaviour is to silently turn 
<code>"daml:collection"</code> into <code>"Literal"</code>).
</p>
<p>The RDF/XML writer is conformant. But does not exercise
much of the grammar.
</p>
<p>
The RDF/XML-ABBREV writer  exercises all of the 
grammar except <code>rdf:bagID</code> and is conformant except
that it uses the "daml:collection" construct for DAML ontologies.
This non-conformant behaviour can be switched off using the 
"blockRules" property.</p>
<p>To create such conformant readers and writers use the following:
</p>
<pre>
   Model m;
   &hellip;
   RDFReader conformantParser = m.getReader();
   conformantParser.setProperty("error-mode","strict");
   &hellip;
   RDFWriter conformantAbbrevWriter = m.getWriter("RDF/XML-ABBREV");
   conformantAbbrevWriter.setProperty("blockRules","daml:collection");
</pre>
<h2><a name="speed">8. Faster RDF/XML I/O</a></h2>
<p>
ARP in Jena2 is significantly faster than in Jena1.
Future optimizations may allow error checking to be suppressed
in response to setting the properties on specific errors. 
Currently only error messages get suppressed. Errors are
checked for, whether or not the message is actually desired.
</p>
<p>
To optimise the speed of writing RDF/XML it is suggested that
all URI processing is turned off. Also do not use RDF/XML-ABBREV.
It is unclear whether the longId attribute is faster or slower;
the short IDs have to be generated on the fly and a table maintained
during writing. The longer IDs are long, and hence take longer to write.
The following creates a faster writer:
</p>
<pre>
   Model m;
   &hellip;
   &hellip;
   RDFWriter fasterWriter = m.getWriter("RDF/XML");
   fasterWriter.setProperty("allowBadURIs","true");
   fasterWriter.setProperty("relativeURIs","");
   fasterWriter.setProperty("tab","0");
</pre>


 
 </BODY>
</HTML>
