<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>
      The Jena Ontology API
    </title>
    <link rev="made" href="mailto:ian.dickinson@hp.com" />
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
    <meta name="generator" content="NoteTab Pro 4.95" />
    <meta name="author" content="Ian Dickinson" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <link href="../styles/doc.css" rel="stylesheet" type="text/css" />
    <!--
      CVS: $Id: index.html,v 1.28 2008-01-02 17:08:22 ian_dickinson Exp $
     (c) Copyright 2003, 2004, 2005, 2006, 2007, 2008 Hewlett-Packard Development Company LP
    -->
  </head>
  <body id="content">
    <h1 class="sectionHeading">
      Jena Ontology API
    </h1>

<p> In this section I will give a general introduction to the
 the Jena2 ontology API. I'll also describe a range
  of common user tasks. I won't go into all of the many details of the API here:
  you should expect to refer to the <a href="../javadoc/index.html">Jena2
  Javadoc</a> to get full details of the capabilities of the API.
      Feedback, (via the <a href="http://tech.groups.yahoo.com/group/jena-dev">jena-dev</a> support list) is welcomed.
    </p>
    <h2>
      Prerequisites
    </h2>

<p> I will assume that you have a basic familiarity with RDF and with Jena.
  There are many other Jena <a href="">help documents</a> you can read for background
  on these topics. There is also a <a href="../tutorial/index.html">Jena programming
  tutorial</a> you can follow through.</p>
  <p>Jena is a programming toolkit, using the Java programming language. While there
  are a few command-line tools to help you perform some key tasks using Jena, mostly
  you use Jena by writing Java programs. The examples in this document will be primarily
  code samples.</p>
  <p>I also won't be explaining the OWL or RDFS ontology languages in much detail
  in this document. You should expect
  to refer to supporting documentation for details on those languages, for example
  the <a href="http://www.w3.org/2004/OWL/">W3C OWL document index</a>.</p>
  <p><strong>Note:</strong> At the time of writing, work on OWL version 1.1 is still underway.
  No decision has yet been made about when Jena will support the new OWL 1.1 features. I will
  only use OWL 1.0 features in this document.</p>

    <h2>Overview</h2>
    <p>
      The section of the manual is broken into a number of sections. It is not necessary to
      read them in sequence, though later sections may refer to concepts and techniques
      introduced in earlier sections. The sections are:
    </p>

<ol>
  <li> Overview </li>
  <li> <a href="#generalConcepts">General concepts</a> and ontology languages
    introduction </li>
  <li> <a href="#cameraExample">Running example: the camera ontology</a> </li>
  <li> <a href="#creatingModels">Creating ontology models</a> </li>
  <li> <a href="#documentHandling">Handling ontology documents and imports</a>
  </li>
  <li> <a href="#ontResource">The generic ontology type: OntResource</a> </li>
  <li> <a href="#classesBasic">Handling ontology components: basic class expressions</a>
  </li>
  <li> <a href="#properties">Handling ontology components: properties</a> </li>
  <li> <a href="#classesComplex">Handling ontology components: more complex class
    expressions</a> </li>
  <li> <a href="#instances">Instances (individuals)</a> </li>
  <li> <a href="#metadata">Ontology meta-data</a> </li>
  <li> <a href="#inferenceIntro">Ontology inference: introduction</a> </li>
  <li><a href="#legacyDAML">Handling DAML+OIL ontologies</a></li>
  <li><a href="#persistence">Working with persistent ontologies</a></li>
  <li> <a href="common-problems.html">Common ontology application problems</a>
    and sample programs</li>
</ol>

    <h3>
      Further assistance
    </h3>
    <p>
      I hope that this document will be sufficient to help most readers to get started
      using the Jena ontology API. For further support, please post questions to the
      Jena support list: <a href="http://tech.groups.yahoo.com/group/jena-dev">jena-dev@yahoogroups</a>.
      You can also report bugs directly into the <a href="https://sourceforge.net/tracker/?atid=430288&group_id=40417&func=browse">Jena bug tracker</a> on
      <a href="http://sourceforge.net/projects/jena">SourceForge</a>.
    </p>
    <p><em>
      Please note that we prefer that you use the support list or the bug-tracker to
      communicate with the Jena team, rather than emailing the team members directly.</em>
    </p>
    <h2 id="generalConcepts">General concepts</h2>
    <p>
      In a widely-quoted definition, an ontology is
    </p>
    <blockquote>
      <p>
        "... a specification of a conceptualization" [<a href="http://www-ksl.stanford.edu/kst/what-is-an-ontology.html">Gruber, T.</a> 1993]
      </p>
    </blockquote>
        <p>Let's unpack that brief characterisation a bit. It means
    that an ontology allows a programmer to specify, in an open, meaningful,
    way the concepts and relationships that collectively characterise some
    domain. Examples might be the concepts of red and white wine, grape
    varieties, vintage years, wineries and so forth that characterise the
    domain of 'wine', and relationships such as 'wineries produce wines',
    'wines have a year of production'. This <em>wine ontology</em> might be
    developed initially for a particular application, such as a
    stock-control system at a wine warehouse. As such, it may be considered
    similar to a well-defined database schema. The advantage to an ontology
    is that it is an explicit, first-class description. So having been
    developed for one purpose, it can be published and reused for other
    purposes. For example, a given winery may use the wine ontology to link
    its production schedule to the stock system at the wine warehouse.
    Alternatively, a wine recommendation program may use the wine ontology,
    and a description (ontology) of different dishes to recommend wines for
    a given menu.</p>
        <p>There are many ways of writing down an ontology, and a variety of
    opinions as to what kinds of definition should go in one. In practice,
    the contents of an ontology are largely driven by the kinds of
    application it will be used to support. In Jena, we do not take a
    particular view on the minimal or necessary components of an ontology.
    Rather, we try to support a variety of common techniques. In this manual
    I try to explain what is &#150; and to some extent what isn't &#150;
    possible using Jena's ontology support.</p>
        <p>Since Jena is fundamentally an RDF platform, Jena's ontology support
        is limited
    to ontology formalisms built on top of RDF. Specifically this means
    <a href="http://en.wikipedia.org/wiki/RDFS">RDFS</a>,
    the varieties of <a href="http://en.wikipedia.org/wiki/Web_Ontology_Language">OWL</a>,
    and the now-obsolete
    <a href="http://en.wikipedia.org/wiki/DAML%2BOIL">DAML+OIL</a>. I will provide a very brief
    introduction to these languages here. Please refer to the
    extensive on-line documentation for these formalisms for complete and
    authoritative detail.</p>
    <h3>
      RDFS
    </h3>
        <p>RDFS is the weakest ontology language supported by Jena. RDFS
    allows the ontologist to build a simple hierarchy of concepts, and a
    hierarchy of properties. Consider the following trivial characterisation
    (with apologies to biology-trained readers!):</p>
    <p class="centered">
      <img src="../images/Simple-hierarchy.png" width="372" height="210" alt="image of simple class hierarchy" />
    </p>
    <p class="caption">
      Table 1: A simple concept hierarchy
    </p>
        <p>Using RDFS, I can say that my ontology has five <em>classes</em>,
    and that <code>Plant</code> is a <em>sub-class of</em> <code>Organism</code> and
    so on. So every animal is also an organism. A good way to think of these
    classes is as describing sets of <em>individuals</em>: organism is
    intended to describe a set of living things, some of which are animals
    (i.e. a sub-set of the set of organisms is the set of animals), and some
    animals are fish (a subset of the set of all animals is the set of all
    fish).</p>
        <p>To describe the attributes of these classes, I can associate <em>properties</em>
    with the classes. For example, animals have sensory organs (noses,
    eyes, etc.). A general property of an animal might be <code>senseOrgan</code>, to
    denote any given sensory organs a particular animal has. In general,
    fish have eyes, so a fish might have a <code>eyes</code> property to
    refer to a description of the particular eye structure of some species.
    Since eyes are
    a type of sensory organ, we can capture this relationship between these
    properties by saying that <code>eye</code> is a sub-property-of <code>senseOrgan</code>.
    Thus if a given fish has two eyes, it also has two sense organs. (It may
    have more, but we know that it must have two).
    </p>
        <p>I can describe this simple hierarchy with RDFS. In general,
    the class hierarchy is a graph rather than a tree (i.e. not like Java class inheritance).
    The <a href="http://en.wikipedia.org/wiki/Slime_mold">slime mold</a> is
    popularly, though perhaps not accurately, thought of as an organism
    that has characteristics of both plants and animals. I might model
    a slime mold in my ontology as a class that has
    both plant and animal classes among
    its super-classes. RDFS is too weak a language to express that a thing
    cannot be both a
    plant and an animal (which is perhaps lucky for the slime molds). In RDFS,
    I can only
    name the classes, I cannot construct expressions to describe
    interesting classes. However, for many applications it is sufficient to
    state the basic vocabulary, and RDFS is perfectly well suited to this.</p>
    <p>Note also that I can both describe classes, in general terms, and
    I can describe particular <em>instances</em>
    of those classes. So there may be a particular individual Fred who is a
    Fish (i.e. has <code>rdf:type Fish</code>), and who has two eyes. His
    companion Freda, a <a href="http://en.wikipedia.org/wiki/Mexican_tetra">
    Mexican Tetra</a>, or blind cave fish, has no eyes. One
    use of an ontology is to allow us to fill-in missing information about
    individuals. Thus, though it is not stated directly, we can deduce that Fred
    is also an Animal and an Organism. Assume that there was no <code>rdf:type</code>
    asserting that Freda is a Fish. We may still infer Freda's <code>rdf:type</code>
    since Freda has <a href="http://en.wikipedia.org/wiki/Lateral_line">lateral lines</a>
    as sense organs, and these only occur in fish. In RDFS, we state that the
    <em>domain</em> of the <code>lateralLines</code> property is the <code>Fish</code>
    class, so an RDFS reasoner can infer that Freda must be a fish.</p>
    <h3>OWL</h3>
        <p>In general, OWL allows me to say everything that RDFS allows, and
    much more besides. A key part of OWL is the ability to describe classes
    in more interesting and complex ways. For example, in OWL we can say
    that Plant and Animal are <em>disjoint classes</em>: no individual can
    be both a plant and an animal (which would have the unfortunate
    consequence of making <code>SlimeMold</code> an empty
    class). <code>SaltwaterFish</code> might be the <em>intersection</em> of
    <code>Fish</code> and
    the class <code>SeaDwellers</code> (which also includes, for example, cetaceans and
    sea plants).</p>
        <p>Suppose I have a property <code>covering</code>, intended to
    represent the scales of a fish or the fur of a mammal. I can now refine
    the mammal class to be 'animals that have a covering that is hair',
    using a <em>property restriction</em> to express the condition that
    property <code>covering</code> has a value from the class <code>Hair</code>.
    Similarly <code>TropicalFish</code> might be the intersection of the
    class of <code>Fish</code> and the class of things that have <code>TropicalOcean</code>
    as their habitat.</p>
        <p>Finally (for this brief overview), I can say more about
    properties in OWL. In RDFS, properties can be related via a property
    hierarchy. OWL extends this by allowing properties to be denoted as <em>transitive</em>,
    <em>symmetric</em> or <em>functional</em>, and allow one property to be
    declared to be the <em>inverse</em> of another. OWL also makes a
    distinction between properties that have data-values (known as <em>literals</em>
    in RDF terminology) as their range, or other individuals. Respectively
    these are <em>datatype properties</em> and <em>object properties</em>.
    A consequence
    of the RDF lineage of OWL is that OWL ontologies cannot make statements
    about literal values. I cannot say in RDF that 7 has the property of
    being a prime number. I can, of course, say that the class of primes includes
    7, but that doesn't require a number to be the subject of an RDF statement.
    In OWL, this distinction is important since only
    object properties can be transitive or symmetric.</p>
    <p> The OWL language is sub-divided into three syntax classes: <em>OWL Lite</em>,
      <em>OWL DL</em> and <em>OWL Full</em>. OWL DL does not permit some
      constructions allowed in OWL Full, and OWL Lite has all the constraints
      of OWL DL plus some more. The
      intent for OWL Lite and OWL DL is to make the task of reasoning with
      expressions in that subset more tractable. Specifically, OWL DL is
      intended to be able to be processed efficiently by a
      <a href="http://en.wikipedia.org/wiki/Description_logic"><em>description
      logic</em></a> reasoner. OWL Lite is intended to be amenable to processing
      by a variety of reasonably simple inference algorithms, though experts
      in the field have challenged how successfully this has been achieved. </p>
        <p>While the OWL standards documents note that OWL builds on top of
    the (revised) RDF specifications, it is possible to treat OWL as a
    separate language in its own right, and not something that is built on
    an RDF foundation. This view uses RDF as a serialisation syntax; the
    RDF-centric view treats RDF triples as the core of the OWL formalism.
    While both views are valid, in Jena we take the RDF-centric view.</p>

      <h3>DAML+OIL</h3>
      <p>DAML+OIL is very similar to OWL Full. This is not surprising,
      since the W3C's Web Ontology Working Group, who designed OWL, took
      DAML+OIL as their starting point. Some constructions in OWL have been
      added to the capabilities of DAML+OIL, and one or two have been removed.
      For the purposes of this brief overview, however, the expressiveness of
      DAML+OIL is comparable to that of OWL.</p><p><strong>Note:</strong> DAML+OIL is effectively now
      obsolete. While you can still find some DAML ontologies on the web, you
      should work with OWL or RDFS to maximise the longevity of your models.</p>

    <h3>Ontology languages and the Jena Ontology API</h3>
    <p>
      As I outlined above, there are various different ontology languages available
      for representing ontology
      information on the semantic web. They range from the most expressive, OWL
      Full, through to the weakest, RDFS. Through the Ontology API, Jena aims to
      provide a consistent programming interface for ontology application
      development, independent of which ontology language you are using in your programs.
    </p>
    <p>
      The Jena Ontology API
      is language-neutral: the Java class names do not mention the underlying language.
      For example, the <code>OntClass</code> Java class can represent an OWL class,
      RDFS class, or DAML class.
      To represent the differences between the various representations,
      each of the ontology languages has a <em>profile</em>, which lists the permitted constructs
      and the names of the classes and properties. Thus in the DAML profile, the URI for object
      property is <code>daml:ObjectProperty</code>
      (short for <code>http://www.daml.org/2001/03/daml+oil#ObjectProperty</code>),
      in the OWL profile is it <code>owl:ObjectProperty</code>
      (short for <code>http://www.w3.org/2002/07/owl#ObjectProperty</code>)
      and in the RDFS profile it is <code>null</code> since RDFS does not define object properties.
    </p>
    <p>
      The profile is bound to an <em>ontology model</em>, which is an extended version of Jena's
      <a href="../javadoc/com/hp/hpl/jena/rdf/model/Model.html"><code>Model</code></a>
      class.
      The base <code>Model</code> allows access to the statements in a collection of RDF data.
      <a href="../javadoc/com/hp/hpl/jena/ontology/OntModel.html"><code>OntModel</code></a>
      extends
      this by adding support for the kinds of objects expected to be in an ontology: classes (in
      a class hierarchy), properties (in a property hierarchy) and individuals. When you're
      working with an ontology in Jena, all of the state information remains encoded as RDF
      triples (which Jena calls <code>Statement</code>s) stored in the RDF model. The ontology
      API <em>doesn't change the RDF representation of ontologies</em>. What it does do is add
      a set of convenience classes and methods that make it easier for you to write programs that
      manipulate the RDF statements.</p>
      <p>The predicate names
      defined in the ontology language correspond to the accessor methods on the Java classes
      in the API. For example, an <code>OntClass</code>
      has a method to list its super-classes, which corresponds to the values of the <code>subClassOf</code>
      property in the RDF representation. This point is worth re-emphasising: no
      information is stored in the <code>OntClass</code> object itself.
      When you call the OntClass <code>listSuperClasses()</code> method, Jena will retrieve the information
      from the underlying RDF statements. Similarly adding a subclass to an <code>OntClass</code>
      asserts an additional RDF statement into the model.
    </p>

    <h3>Ontologies and reasoning</h3>
    <p>One of the main reasons for building an ontology-based application is to use
    a reasoner to derive additional truths about the concepts you are modelling. We
    saw a simple instance of this above: the assertion &quot;Fred is a Fish&quot; <em>entails</em>
    the deduction &quot;Fred is an Animal&quot;. There are many different styles of automated
    reasoner, and very many different reasoning algorithms. Jena includes support
    for a variety of reasoners through the
    <a href="../inference/index.html">inference API</a>. A common feature of Jena
    reasoners is that they create a new RDF model which appears to contain the triples
    that are derived from reasoning, as well as the triples that were asserted in
    the base model. This extended model is, nevertheless, still conforms to the contract
    for Jena models. So it can be used wherever a base model can be used. The ontology
    API exploits this feature: the convenience methods the ontology API provides can
    query an extended inference model in just the same way as a plain RDF model. In fact,
    this is such a common pattern that we provide simple recipes for constructing
    ontology models whose language, storage model and reasoning engine can all be
    simply specified when an <code>OntModel</code> is created. I'll show examples later.</p>
        <p>Figure 2 shows one way of visualising this:</p>
    <p class="centered">
      <img src="../images/Ont-model-layers.png" width="312" height="285" alt="image of layering of graphs in model" />
    </p>
    <p class="centered">Figure 2: the statements seen by the OntModel</p>
    <p><code>Graph</code> is an internal Jena interface that supports the composition
    of sets of RDF triples. The asserted statements, which may have been read in
    from an ontology document, are held in the base graph.
    The reasoner, or
    inference engine, can use the contents of the base graph and the
    semantic rules of the language to show a more complete set of
    statements. This is also presented via a <code>Graph</code> interface,
    so the model works only with the outermost interface.
    This regularity allows us to very easily build
    ontology models with or without a reasoner. It also means that the
    base graph can be an in-memory store, a database-backed persistent
    store, or some other storage structure altogether (e.g. an LDAP
    directory) again without affecting the operation of the ontology model.</p>
    <h3 id="rdfPolymorphism">RDF-level polymorphism and Java</h3>
    <p>
      Deciding which Java abstract class to use to represent a given RDF resource
      can be surprisingly subtle. Consider the following RDF sample:
    </p>
    <pre>
&lt;owl:Class rdf:ID="DigitalCamera"&gt;
&lt;/owl:Class&gt;</pre>
      <p>This declares that the resource with the relative URI
  <code>#DigitalCamera</code> is an OWL ontology class. It suggests that it
  would be appropriate to model
  that declaration in Java with an instance of an <code>OntClass</code>. Now
  suppose we add a triple to the RDF model to augment the class
  declaration with some more information:</p>
    <pre>
&lt;owl:Class rdf:ID="DigitalCamera"&gt;
  &lt;rdf:type owl:Restriction /&gt;
&lt;/owl:Class&gt;</pre>
    <p>Now I am saying that <code>#DigitalCamera</code> is an OWL
    Restriction. Restriction is a subclass of <code>owl:Class</code>, so this is a perfectly
    consistent operation. The problem I have is that Java does not allow
    me to dynamically change the Java class of the object representing this
    resource. The resource has not changed: it still has URI <code>#DigitalCamera</code>.
    But the appropriate Java class Jena might choose to model it has changed
    from <code>OntClass</code> to <code>Restriction</code>. Conversely, if
    I subsequently remove the <code>rdf:type&nbsp;owl:Restriction</code> from the model, using the
    <code>Restriction</code> Java class is no longer appropriate.</p>
<p>
      Even worse, OWL Full allows me to state the following (rather counter-intuitive) construction:
    </p>
    <pre>
&lt;owl:Class rdf:ID="DigitalCamera"&gt;
  &lt;rdf:type owl:ObjectProperty /&gt;
&lt;/owl:Class&gt;</pre>
    <p>That is, <code>#DigitalCamera</code> is both a class <em>and</em>
    a property. While this may not be a very useful operation, it
    illustrates a basic point: we cannot rely on a consistent or unique
    mapping between an RDF resource and the appropriate Java abstraction.</p>
        <p>Jena accepts this basic characteristic of polymorphism at the
    RDF level by considering that the Java abstraction (<code>OntClass</code>,
    <code>Restriction</code>, <code>DatatypeProperty</code>, etc.) is just a view or <em>facet</em> of
    the resource. That is, there is a one-to-many mapping from a resource to
    the facets that the resource can present. If the resource is typed as
    an <code>owl:Class</code>, it can present the <code>OntClass</code> facet;
    given other types, it can present other facets. Jena provides the
    <code>.as()</code> method to efficiently map from an RDF object to one of
    its allowable facets.
    Given a RDF object (i.e. an instance of <code>com.hp.hpl.jena.rdf.model.RDFNode</code>
    or one of its sub-types), I can get a facet by invoking <code>as()</code>
    with an argument that denotes the facet required. Specifically, the facet is
    identified by the Java class object of the desired facet. For example, to
    get the <code>OntClass</code> facet of a resource, I can do:</p>
    <pre>
Resource r = myModel.getResource( myNS + "DigitalCamera" );
OntClass cls = (OntClass) r.as( OntClass.class );</pre>
        <p>This pattern allows me to defer decisions about
    the correct Java abstraction to use until run-time. The choice can depend on the
    properties of the resource itself. If a given RDFNode will not support
    the conversion to a given facet, it will raise a <code>ConversionException</code>.
    I can test if <code>.as()</code> will succeed for a given facet with
    <code>canAs()</code>. This RDF-level polymorphism is used extensively in
    the Jena ontology API to allow maximum flexibility in handling ontology data.
    </p>

    <h2 id="cameraExample">Running example: the ESWC ontology</h2>

<p> To illustrate the principles of using the ontology API, I will use examples drawn
  from Tom Heath's
    <a href="http://www.schemaweb.info/schema/SchemaDetails.aspx?id=282">ESWC ontology</a>.
    This ontology presents a simple model for describing the concepts and activities
    associated with a typical academic conference.
   A copy of the ontology serialized in N3 is included with the Jena
  download, see: [<a href="../../src-examples/data/eswc-2006-09-21.rdf"><code>eswc-2006-09-21.rdf</code></a>]. </p>
    <p>
      A subset of the classes and properties from the ontology are shown in Figure 3:
    </p>
    <p class="centered">
      <img src="../images/eswc-classes.png" width="589" height="487" alt="image of class hierarchy" />
    </p>
    <p class="caption">
      Figure 3: Classes and properties from ESWC ontology
    </p>
    <p>
      I will use elements from this ontology to illustrate the ontology API throughout
      the rest of this document.
    </p>

    <h2 id="creatingModels">Creating ontology models</h2>

  <p> An ontology model is an extension of the Jena RDF model that provides extra
    capabilities for handling ontologies. Ontology models are created
    through the Jena <a href="../javadoc/com/hp/hpl/jena/rdf/model/ModelFactory.html"><code>ModelFactory</code></a>.
    The simplest way to create an ontology model is as follows: </p>
    <pre class="codesample">
OntModel m = ModelFactory.createOntologyModel();</pre>
    <p>This will create an ontology model with the <em>default</em> settings, which
    are set for maximum compatibility with the previous version of Jena. These defaults
    are:</p>
    <ul>
    <li>OWL-Full language</li>
    <li>in-memory storage</li>
    <li>RDFS inference, which principally produces entailments from the
      sub-class and sub-property hierarchies.</li>
    </ul>
    <p>In many applications, such as driving a GUI, RDFS inference is too strong (for example, every
    class is inferred to be a sub-class of <code>owl:Thing</code>. In other applications, stronger
    reasoning is needed. In general, to create an <code>OntModel</code> with a particular reasoner
    or language profile, you should pass a model specification to the <code>createOntologyModel</code>
    call. For example, an OWL model that performs no reasoning at all can be created with:</p>
    <pre class="codesample">
OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );</pre>
        <p>To create an ontology model for a particular language, but
    leaving all of the other values as defaults, you should pass the URI of the
    ontology language to the model factory. The URI strings for the various
    language profiles are:</p>
    <table width="500" border="1" cellspacing="1" cellpadding="1" summary="ontology languague URIs">
      <tr>
        <th width="101">
          Ontology<br />
           language
        </th>
        <th width="386">
          URI
        </th>
      </tr>
      <tr>
        <td width="101">
          RDFS
        </td>
        <td width="386">
          <div align="left">
            <code>http://www.w3.org/2000/01/rdf-schema#</code>
          </div>
        </td>
      </tr>
      <tr>
        <td width="101">
          DAML+OIL
        </td>
        <td width="386">
          <div align="left">
            <code>http://www.daml.org/2001/03/daml+oil#</code>
          </div>
        </td>
      </tr>
      <tr>
        <td width="101">
          OWL Full
        </td>
        <td width="386">
          <div align="left">
            <code>http://www.w3.org/2002/07/owl#</code>
          </div>
        </td>
      </tr>
      <tr>
        <td width="101">
          OWL DL
        </td>
        <td width="386">
          <div align="left">
            <code>http://www.w3.org/TR/owl-features/#term_OWLDL</code>
          </div>
        </td>
      </tr>
      <tr>
        <td width="101">
          OWL Lite
        </td>
        <td width="386">
          <div align="left">
            <code>http://www.w3.org/TR/owl-features/#term_OWLLite</code>
          </div>
        </td>
      </tr>
    </table>

  <p> These URI's are used to look-up the language profile from the
  <a href="../javadoc/com/hp/hpl/jena/ontology/ProfileRegistry.html"><code>ProfileRegistry</code></a>.
  Fortunately, the profile registry contains declared constants so that you do
  not have to remember these URI's. Please note that the URI's denoting OWL Lite
  and OWL DL are not officially sanctioned by the OWL standard. </p>
    <p>
      To create an ontology model for handling DAML ontologies, use either of:
    </p>
    <pre>
OntModel m = ModelFactory.createOntologyModel( OntModelSpec.DAML_MEM );
OntModel m = ModelFactory.createOntologyModel( ProfileRegistry.DAML_LANG );</pre>

<p> Beyond these basic choices, the complexities of configuring an ontology model
  are wrapped up in a recipe object called
  <code><a href="../javadoc/com/hp/hpl/jena/ontology/OntModelSpec.html">OntModelSpec</a></code>.
  This specification allows complete control over the configuration choices for the ontology
  model, including the language profile in use, the reasoner, and the means of
  handling compound documents. A number of common recipes are
  pre-declared as constants in OntModelSpec, and listed below.</p>

      <table width="700" border="1" cellspacing="1" cellpadding="1" summary="pre-defined OntModel specifications">
      <tr><th width="100">OntModelSpec</th><th width="100">Language profile</th><th width="100">Storage model</th><th width="300">Reasoner</th></tr>
      <tr><td width="100" class="codesample">OWL_MEM</td><td>OWL full</td><td>in-memory</td><td>none</td></tr>
      <tr><td width="100" class="codesample">OWL_MEM_TRANS_INF</td><td>OWL full</td><td>in-memory</td><td>transitive class-hierarchy inference</td></tr>
      <tr><td width="100" class="codesample">OWL_MEM_RULE_INF</td><td>OWL full</td><td>in-memory</td><td>rule-based reasoner with OWL rules</td></tr>
      <tr><td width="100" class="codesample">OWL_MEM_MICRO_RULE_INF</td><td>OWL full</td><td>in-memory</td><td>optimised rule-based reasoner with OWL rules</td></tr>
      <tr><td width="100" class="codesample">OWL_MEM_MINI_RULE_INF</td><td>OWL full</td><td>in-memory</td><td>rule-based reasoner with subset of OWL rules</td></tr>
      <tr><td width="100" class="codesample">OWL_DL_MEM</td><td>OWL DL</td><td>in-memory</td><td>none</td></tr>
      <tr><td width="100" class="codesample">OWL_DL_MEM_RDFS_INF</td><td>OWL DL</td><td>in-memory</td><td>rule reasoner with RDFS-level entailment-rules</td></tr>
      <tr><td width="100" class="codesample">OWL_DL_MEM_TRANS_INF</td><td>OWL DL</td><td>in-memory</td><td>transitive class-hierarchy  inference</td></tr>
      <tr><td width="100" class="codesample">OWL_DL_MEM_RULE_INF</td><td>OWL DL</td><td>in-memory</td><td>rule-based reasoner with OWL rules</td></tr>
      <tr><td width="100" class="codesample">OWL_LITE_MEM</td><td>OWL Lite</td><td>in-memory</td><td>none</td></tr>
      <tr><td width="100" class="codesample">OWL_LITE_MEM_TRANS_INF</td><td>OWL Lite</td><td>in-memory</td><td>transitive class-hierarchy inference</td></tr>
      <tr><td width="100" class="codesample">OWL_LITE_MEM_RDFS_INF</td><td>OWL Lite</td><td>in-memory</td><td>rule reasoner with RDFS-level entailment-rules</td></tr>
      <tr><td width="100" class="codesample">OWL_LITE_MEM_RULES_INF</td><td>OWL Lite</td><td>in-memory</td><td>rule-based reasoner with OWL rules</td></tr>
      <tr><td width="100" class="codesample">DAML_MEM</td><td>DAML+OIL</td><td>in-memory</td><td>none</td></tr>
      <tr><td width="100" class="codesample">DAML_MEM_TRANS_INF</td><td>DAML+OIL</td><td>in-memory</td><td>transitive class-hierarchy inference</td></tr>
      <tr><td width="100" class="codesample">DAML_MEM_RDFS_INF</td><td>DAML+OIL</td><td>in-memory</td><td>rule reasoner with RDFS-level entailment-rules</td></tr>
      <tr><td width="100" class="codesample">DAML_MEM_RULE_INF</td><td>DAML+OIL</td><td>in-memory</td><td>rule-based reasoner with DAML rules</td></tr>
      <tr><td width="100" class="codesample">RDFS_MEM</td><td>RDFS</td><td>in-memory</td><td>none</td></tr>
      <tr><td width="100" class="codesample">RDFS_MEM_TRANS_INF</td><td>RDFS</td><td>in-memory</td><td>transitive class-hierarchy inference</td></tr>
      <tr><td width="100" class="codesample">RDFS_MEM_RDFS_INF</td><td>RDFS</td><td>in-memory</td><td>rule reasoner with RDFS-level entailment-rules</td></tr>
      </table>


<p>For details of reasoner capabilities, please see the <a href="../inference/index.html">inference
  documentation</a> and the Javadoc for <a href="../javadoc/com/hp/hpl/jena/ontology/OntModelSpec.html">OntModelSpec</a>.
  See also further discussion <a href="#inferenceIntro">below</a>.
  </p>

<p> <strong>Note:</strong> it is primarily the choice of reasoner, rather than the choice of language
  profile, that determines which entailments are seen by the ontology model. However,
  using an OWL reasoner with DAML source data will result in few additional entailments
  being seen by the ontology model. </p>

<p> To create a model with a given specification, you should invoke the <code>ModelFactory</code>
  as follows: </p>
    <pre class="codesample">OntModel m = ModelFactory.createOntologyModel( <em>&lt;model spec&gt;</em> );</pre>
    <p>for example:</p>
    <pre class="codesample">OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_MICRO_RULE_INF );</pre>
    <p>To create a custom model specification, you can create a new one
from its constructor, and call the various setter methods to set the appropriate values.
More often, you want a variation on an existing recipe. In this
case, you copy an existing specification and then update the copy as
necessary:</p>
    <pre class="codesample">OntModelSpec s = new OntModelSpec( OntModelSpec.OWL_MEM );
s.setDocumentManager( myDocMgr );
OntModel m = ModelFactory.createOntologyModel( s );</pre>

    <h2 id="documentHandling">Compound ontology documents and imports processing</h2>

    <p>The OWL and DAML ontology languages include some facilities for creating modular
    ontologies that can be re-used in a similar manner to software modules. In particular,
    one ontology can <em>import</em> another. Jena helps ontology developers to work
    with modular ontologies by automatically handling the imports statements in
    ontology models.</p>
    <p>The key idea is that the base model of an ontology model is actually a collection
    of models, one per imported model. That means we have to modify figure 2 a bit.
    Figure 4 shows how the ontology model builds a collection of import models:</p>
    <p class="centered">
      <img src="../images/Ont-model-layers-import.png" width="563" height="331" alt="Diagram of compound document for imports" />
    </p>
    <p class="caption">Figure 4: ontology model compound document structure for imports</p>

  <p>I will use the term <em>document</em> to describe an ontology serialized in some
    transport syntax, such as RDF/XML or N3. This terminology isn't used by the OWL
    or RDFS standards, but it is a convenient way to refer to the written artifacts.
    However, from a broad view of the interlinked semantic web, a document view imposes
    artificial boundaries between regions of the global web of data.</p>
    <p>We will load an ontology document into an
    ontology model in the same way as a normal Jena model, using the <code>read</code>
    method. There are several variants on read, that handle differences in the source
    of the document (to be read from a resolvable URL or directly from an input
    stream or reader), the base URI that will resolve any relative URI's in the
    source document, and the serialisation language. In summary, these variants
    are: </p>
    <pre class="codesample">read( String url )
read( Reader reader, String base )
read( InputStream reader, String base )
read( String url, String lang )
read( Reader reader, String base, String Lang )
read( InputStream reader, String base, String Lang )</pre>
      <p>You can use any of these methods to load an ontology document.
  Note that we advise that you avoid the the <code>read()</code> variants that
  accept  a  <code>java.io.Reader</code> argument
  when loading XML documents containing internationalised
  character sets, since the handling of character encoding by the Reader
  and by XML parsers is not compatible.
  </p>
      <p>By default, when an ontology model reads an ontology document, it
      will also locate and load the document's imports. An OWL or DAML document
  may contain an individual of class <code>Ontology</code>, which contains meta-data
  about that document itself. For example:</p>
    <pre>
&lt;owl:Ontology rdf:about=""&gt;
  &lt;dc:creator rdf:value="Ian Dickinson" /&gt;
  &lt;owl:imports rdf:resource="http://jena.hpl.hp.com/example-ont" /&gt;
&lt;/owl:Ontology&gt;</pre>
    <p>The construct <code>rdf:about=&quot;&quot;</code> is a relative URI that
      will resolve to the document's base URI: in other words it's a shorthand
      way of referring to the document itself. The <code>owl:imports</code> line
       states that this ontology is
      constructed using classes, properties and individuals from the referenced
      ontology. When <code>OntModel</code> reads this document, it will notice
      the <code>owl:imports</code> line and attempt to load the imported ontology
      into a sub-model of the ontology model being built. The definitions from both the
      base ontology and all of the imports will be visible to the reasoner.</p>

    <p>Each imported ontology document is held in a separate graph structure.
      This is important: I want to keep the original source ontology separate
      from the imports. When I write the model out again, normally only the base
      model is written (the alternative is that all you see is a confusing union
      of everything). And when I update the model, only the base model changes.
    </p>
        <p>Imports are processed recursively, so if my base document
    imports ontology A, and A imports B, I will end up with the structure
    shown in Figure 4. Note that the imports have been flattened out.
    A cycle check is used to prevent the document
    handler getting stuck if, for example, A imports B which imports A!</p>

    <h3>The ontology document manager</h3>
    <p>
      Each ontology model has an associated <em>document manager</em> that assists with
      the processing and handling of documents-related concerns. For convenience,
      there is one global document manager that is used by default by ontology
      models. You  can get a reference to this shared instance through
      <code>OntDocumentManager.getInstance()</code>. In many cases,
      it will be sufficient to simply change the settings on the global
      document manager to suit your application's needs. However, for
      more fine-grain control, you can create
      separate document managers,  and pass them
      to the ontology model when it is created through the model factory.
      To do this, create an ontology specification object (see above),
      and set the document manager. For example:
    </p>
    <pre class="codesample">OntDocumentManager mgr = new OntDocumentManager();
// set the mgr's properties now
 ... some code ...
// now use it
OntModelSpec s = new OntModelSpec( OntModelSpec.RDFS_MEM );
s.setDocumentManager( mgr );
OntModel m = ModelFactory.createOntologyModel( s );</pre>
        <p>Note that the model retains a reference to the document manager
    it was created with. Thus if you change a document manager's properties,
    it will
    affect models that have previously been constructed with that document
    manager.</p>

    <h3>Document manager policy</h3>
        <p>Since the document manager has a large number of configurable
    options, there are two ways in which you can customise it to your
    application
    requirements. Firstly, you can set the individual parameters of the document manager
    by Java code. Alternatively, when a given document manager is
    created it can load values for the various parameters from a policy
    file, expressed in RDF. The document manager has a list of URL's
    which it will search for a policy document. It will stop at the first
    entry on the list that resolves to a retrievable document. The default
    search path for the policy is: <code>file:./etc/ont-policy.rdf;file:ont-policy.rdf</code>.
    You can find the default policy, which can serve as a template for defining
    your own policies, in the <code>etc/</code> directory under the
    Jena download directory.</p>
    <p>
      You can set the general properties of the document manager in the policy as follows:
    </p>
    <pre class="codesample">&lt;DocumentManagerPolicy&gt;
  &lt;!-- policy for controlling the document manager's behaviour --&gt;
  &lt;processImports rdf:datatype="&amp;xsd;boolean"&gt;true&lt;/processImports&gt;
  &lt;cacheModels rdf:datatype="&amp;xsd;boolean"&gt;true&lt;/cacheModels&gt;
&lt;/DocumentManagerPolicy&gt;</pre>

    <p>
      You can find the simple schema that declares the various properties that you can use in
      such an ontology document policy in the vocabularies directory of the Jena download. It's called <code>ont-manager.rdf</code>. To change the search path that
      the document manager will use to initialise itself, you can either pass the new
      search path as a string when creating a new document manager object, or
      call the method <code>setMetadataSearchPath()</code>.</p>

    <h3>The ModelMaker: creating storage on demand</h3>

  <p> In order for the document manager to build the union of the imported documents
    (which we may refer to as the <em>imports closure</em>), there must be some means of creating
    new graphs to store the imported ontologies. Loading a new import means that there
    needs to be a new graph added
    Jena defines a <em>model maker</em> as a simple interface that allows
    different kinds of model storage (in memory, file-backed, in a persistent database, etc.)
    to be created  on demand. For the database case, this may include passing the database
    user-name and password and other connection parameters. New model makers can
        be created with the <code><a href="../javadoc/com/hp/hpl/jena/rdf/model/ModelFactory.html">ModelFactory</a></code>.</p>
    <p>There are two cases in which we may want to create storage for
    models on-demand. The first is when creating the <code>OntModel</code>
    for the first time, some variants of <code>createOntologyModel</code>
    will allocate space for the <em>base model</em> (instead of, for
    example, being handed a base model to use as one of the method
    arguments). The second case when storage must be allocated is when
    adding an imported document to the union of imports. These cases often
    require different policies, so the <code>OntModelSpec</code> contains
    two model maker parameters: the <em>base model maker</em> and <em>imports
    model maker</em>, available via <code>getBaseModelMaker()</code> and <code>getImportsModelMaker()</code>
    methods respectively.</p>

    <p>The default specifications in OntModelSpec that begin MEM_ use an
    in-memory model maker for the both the base model and the imported
    documents.</p>
    <p><strong>Implementation note</strong>: internally to Jena, we use
    <code>Graph</code> as a primary data structure. However, your code will
    almost always refer to models, not graphs. What's happening is that a <code>Model</code>
    is a wrapper around the <code>Graph</code>, which balances a rich,
    convenient programing interface (<code>Model</code>) with a simple,
    manageable internal data structure (<code>Graph</code>). Hence some
    potential confusion in that Figure 4, above, refers to a structure
    containing graphs, but we use a <code><a
      href="../javadoc/com/hp/hpl/jena/rdf/model/ModelMaker.html"
    >ModelMaker</a></code> to generate new stores. The document manager extracts the
    appropriate graph from the containing model. Except in cases where you
    are extending Jena's internal structures, you should think of <code>Model</code>
    as the container of RDF and ontology data.</p>

<h3>Controlling imports processing</h3>

        <p>Normally, loading imports during the <code>read()</code> call
    automatic. To <code>read()</code> an ontology without building the imports closure, call
    the method <code>setProcessImports(&nbsp;false&nbsp;)</code> on the
    document manager object before calling <code>read()</code>.
    Alternatively, you can set the <code>processImports</code> property
    in the policy file. You can also be more selective, and ignore only
    certain URI's when loading the imported documents.
    To selectively skip certain named imports,
    call the method <code>addIgnoreImport(&nbsp;String&nbsp;uri&nbsp;)</code>
    on the document manager object, or set the <code>ignoreImport</code>
    property in the policy.</p>

    <h3>Managing file references</h3>
        <p>An advantage of working with ontologies is that we can reuse work
    done by other ontologists, by importing their published ontologies into
    our own.
    Sometimes, however, this means that there is an Internet firewall between the ontology-based
    application and the source of an imported ontology. Even if it's possible to
    traverse the firewall through an HTTP proxy, retrieving files from an HTTP
    connection may impose unacceptable delays when starting an application.
    In the worst case, we may find that ontology on which our application depends is
    temporarily or permanently unavailable from the original published URL.
    To alleviate these commonly experienced problems, you can use the
    ontology document manager to set up a
    a local indirection, so that an attempt to import a document from a
    given published URL means that a local copy of the document is retrieved
    instead. This may be a file copy, or simply a pointer to a local
    mirror web site.</p>
    <p>
      To specify this local redirection in the policy file, use the following declarations:
    </p>
    <pre class="codesample">&lt;OntologySpec&gt;
  &lt;publicURI rdf:resource="... the public URI to map from..."    /&gt;
  &lt;altURL rdf:resource="... the local URL to map to ..." /&gt;
  &lt;!-- optional ontology language term --&gt;
  &lt;language rdf:resource="... encoding used ..." /&gt;
  &lt;!-- optional prefix to associate with the public URL --&gt;
  &lt;prefix rdf:datatype="&amp;xsd;string"&gt;a prefix&lt;/prefix&gt;
&lt;/OntologySpec&gt;</pre>
    <p>For example:</p>
    <pre class="codesample">&lt;OntologySpec&gt;
  &lt;!-- local version of the RDFS vocabulary --&gt;
  &lt;publicURI rdf:resource="http://www.w3.org/2000/01/rdf-schema"    /&gt;
  &lt;altURL rdf:resource="file:vocabularies/rdf-schema.rdf" /&gt;
&lt;/OntologySpec&gt;</pre>
        <p>This specifies that an attempt to load the RDFS vocabulary from <code>http://www.w3.org/2000/01/rdf-schema</code>
    will transparently cause <code>file:vocabularies/rdf-schema.rdf</code>
    to be fetched instead. You can specify any number of such re-directions
    in the policy file, or you can add them to the document manager object
    directly by calling the various setter methods (see the Javadoc for
    details). As a side-effect, this mechanism also means that ontologies
    may be named with any legal URI (not necessarily resolvable) - so long
    as the <code>altURL</code> is itself resolvable.</p>
    <p>Note that the <code>OntDocumentManager</code> is an application of Jena's
    <a href="../how-to/filemanager.html">File Manager</a>. See the notes on FileManager for details of
    additional options.</p>

  <p> In the following example, I programmatically declare that the ESWC ontology
    is replicated locally on disk, and then I load it using the public URL. Assume that the constant
    <code>JENA</code> has been initialised to the directory in which Jena was installed. </p>
      <pre class="codesample">
  OntModel m = ModelFactory.createOntologyModel();
  OntDocumentManager dm = m.getDocumentManager();
  dm.addAltEntry( "http://www.eswc2006.org/technologies/ontology",
                  "file:" + JENA + "src-examples/data/eswc-2006-09-21.rdf"    );
  m.read( "http://www.eswc2006.org/technologies/ontology" );</pre>

    <h3>Specifying prefixes</h3>

    <p> A model keeps a table of URI prefixes that can be used to render URI's in
      the shortened prefix:name form, which is useful in displaying URI's in a readable
      way in user interfaces, and is essential in producing legal XML names that denote
      arbitrary URI's. The ontology model's table of prefixes can be initialized from
      a table kept by the document manager, which contains the standard prefixes plus
      any that are declared by in the policy file (or added to subsequently by method
      calls). To prevent the model's prefix table from being initialized in this way,
      use the property <code>useDeclaredNsPrefixes</code> in the policy file (with
      value <code>false</code>), or call the method <code>setUseDeclaredPrefixes</code> on the
      ontology object. </p>

    <h3>Caching of imported models</h3>
        <p>You can use the document manager to assist
    with loading ontology documents through its cache. Suppose two
    ontologies, A and B both import ontology C. We would like not to have
    to read C twice when loading A and then B. The document manager supports this
    use case by optionally caching C's model, indexed by URI. When A tries
    to import C, there is no cached copy, so a new model is created for C,
    the contents of C's URL read in to the model, then the C model is used in the
    compound document for A. Subsequently, when ontology B is loading imports,
    the document manager checks in its cache and finds an existing copy
    of C. This will be used in preference to reading a fresh copy of C from
    C's source URL, saving both time and storage space.</p>
        <p>Caching of import models is switched on by default.
    To turn it off, use the policy property <code>cacheModels</code>,
    or call the method <code>setCacheModels(&nbsp;boolean&nbsp;caching&nbsp;)</code>
    with <code>caching = false</code>.
    The document manager's current model cache
    can be cleared at any time by calling <code>clearCache()</code>.</p>

    <h2 id="ontResource">The generic ontology type: OntResource</h2>

<p> All of the classes in the ontology API that represent ontology values have
  <code><a href="../javadoc/com/hp/hpl/jena/ontology/OntResource.html">OntResource</a></code>
  as a common super-class. This makes <code>OntResource</code> a good place to
  put shared functionality for all such classes, and makes a handy common return
  value for general methods. The Java interface <code>OntResource</code> extends
  Jena's RDF <code><a href="../javadoc/com/hp/hpl/jena/rdf/model/Resource.html">Resource</a></code>
  interface, so any general method that accepts a resource or an <code><a href="../javadoc/com/hp/hpl/jena/rdf/model/RDFNode.html">RDFNode</a></code>
  will also accept an <code>OntResource</code>, and consequently, any other ontology
  value. </p>
    <p>
      Some of the common attributes of ontology resources that are expressed through methods on OntResource are shown below:
    </p>
    <table width="650" border="1" cellspacing="1" cellpadding="1" summary="properties of OntResource">
      <tr>
        <th width="150">
          Attribute
        </th>
        <th width="500">
          Meaning
        </th>
      </tr>
      <tr>
        <td>versionInfo</td>
        <td>
            A string documenting the version or history of this resource
        </td>
      </tr>
      <tr>
        <td>comment</td>
        <td>
            A general comment associated with this value
        </td>
      </tr>
      <tr>
        <td>label</td>
        <td>
            A human-readable label
        </td>
      </tr>
      <tr>
        <td>seeAlso</td>
        <td>
            Another web location to consult for more information about this resource
        </td>
      </tr>
      <tr>
        <td>isDefinedBy</td>
        <td>
            A specialisation of seeAlso that is intended to supply a definition of this resource
        </td>
      </tr>
      <tr>
        <td>sameAs</td>
        <td>
            Denotes another resource that this resource is equivalent to
        </td>
      </tr>
      <tr>
        <td>differentFrom</td>
        <td>
            Denotes another resource that is distinct from this resource (by definition)
        </td>
      </tr>
    </table>
    <p>
      For each of these properties, there is a standard pattern of available methods:
    </p>
    <table width="650" border="1" cellspacing="1" cellpadding="1">
      <tr>
        <th width="150">
          Method
        </th>
        <th width="500">
          Effect
        </th>
      </tr>
      <tr>
        <td>add&lt;property&gt;</td>
        <td>
            Add an additional value for the given property
        </td>
      </tr>
      <tr>
        <td>set&lt;property&gt;</td>
        <td>
            Remove any existing values for the property, then add the given value
        </td>
      </tr>
      <tr>
        <td>list&lt;property&gt;</td>
        <td>
            Return an iterator ranging over the values of the property
        </td>
      </tr>
      <tr>
        <td>get&lt;property&gt;</td>
        <td>
            Return the value for the given property, if the resource has one. If not, return null. If it has more than one value, an arbitrary selection is made.
        </td>
      </tr>
      <tr>
        <td>has&lt;property&gt;</td>
        <td>
            Return true if there is at least one value for the given property. Depending on the name of the property, this is sometimes is&lt;property&gt;
        </td>
      </tr>
      <tr>
        <td>remove&lt;property&gt;</td>
        <td>
            Removes a given value from the values of the property on this resource. Has no effect if the resource does not have that value.
        </td>
      </tr>
    </table>

        <p>For example: <code>addSameAs(&nbsp;Resource&nbsp;r&nbsp;)</code>,
        or <code>isSameAs(&nbsp;Resource&nbsp;r&nbsp;)</code>. For full details
        of the individual methods, please consult the Javadoc.</p>
    <p>
      <code>OntResource</code> defines some other general utility
        methods. For example, to find out how many values a resource has for a
        given property, you can call <code>getCardinality(&nbsp;Property&nbsp;p&nbsp;)</code>.
        To delete the resource from the ontology altogether, you can call <code>remove()</code>.
        The effect of this is to remove every statement that mentions this
        resource as a subject or object of a statement. </p>
      <p>To get or set the value
        of a given property, use <code>getPropertyValue(&nbsp;Property&nbsp;p&nbsp;)</code>
        or <code>setPropertyValue(&nbsp;Property&nbsp;p,&nbsp;RDFNode&nbsp;value&nbsp;)</code>.
        Continuing the naming pattern,
        the values of a named property can be listed (with <code>listPropertyValues</code>),
        removed (with <code>removeProperty</code>) or added (with <code>addProperty</code>). </p>
        <p>Finally, <code>OntResource</code> provides methods for listing,
        getting and setting the <code>rdf:type</code> of a resource, which denotes a
        class to which the resource belongs (remember that in RDF and OWL, a resource can belong
        to many classes at once). The <code>rdf:type</code> property
        is one for which many entailment rules are defined in the semantic
        models of the various ontology languages. Therefore, the values that <code>listRDFTypes()</code>
        returns is more than usually dependent on the actual reasoner bound to
        the ontology model. For example, suppose I have class A, class B which
        is a subclass of A, and resource x whose asserted <code>rdf:type</code>
        is B. With no reasoner, listing x's RDF types will return only B. If the
        reasoner is able to calculate the closure of the subclass hierarchy (and
        most can), X's RDF types would also include A. A complete OWL
        reasoner would also infer that x has <code>rdf:type</code> <code>owl:Thing</code>
        and <code>rdf:Resource</code>.
        </p>
        <p>For some tasks, getting a complete list of the RDF types of a
      resource is exactly what is needed. For other tasks, this is not the
      case. If you are developing an ontology editor, for example,
      you may want to distinguish in its
      display between inferred and asserted types. In the above example, only
      <code>x&nbsp;rdf:type&nbsp;B</code> is asserted, everything else is
      inferred. One way to make this distinction is to make use of the base
      model (see Figure 4). Getting the resource from the base model and
      listing the type properties there would return only the asserted values.
      For example:     </p>
      <pre class="codesample">
// create the base model
String SOURCE = &quot;http://www.eswc2006.org/technologies/ontology&quot;;
String NS = SOURCE + &quot;#&quot;;
OntModel base = ModelFactory.createOntologyModel( OWL_MEM );
base.read( SOURCE, &quot;RDF/XML&quot; );

// create the reasoning model using the base
OntModel inf = ModelFactory.createOntologyModel( OWL_MEM_MICRO_RULE_INF, base );

// create a dummy paper for this example
OntClass paper = base.getOntClass( NS + &quot;Paper&quot; );
Individual p1 = base.createIndividual( NS + &quot;paper1&quot;, paper );

// list the asserted types
for (Iterator i = p1.listRDFTypes(); i.hasNext(); ) {
    System.out.println( p1.getURI() + &quot; is asserted in class &quot; + i.next() );
}

// list the inferred types
p1 = inf.getIndividual( NS + &quot;paper1&quot; );
for (Iterator i = p1.listRDFTypes(); i.hasNext(); ) {
    System.out.println( p1.getURI() + &quot; is inferred to be in class &quot; + i.next() );
}</pre>
    <p id="direct_relationships">For other user interface or
    presentation tasks, we may want something between the complete list of
    types and the base list of only the asserted values. Consider the
    class hierarchy in figure 5 (i):</p>
    <p class="centered">
      <img src="../images/Direct-hierarchy.png" width="595" height="315" alt="Diagram showing direct relationships" />
    </p>
    <p class="caption">
      Figure 5: asserted and inferred relationships
    </p>
    <p>Figure 5 (i) shows a base model, containing a class hierarchy and
    an instance x. Figure 5 (ii) shows the full set of relationships that might
    be inferred from this base model. In Figure 5 (iii), we see only the <em>direct</em>
    or maximally specific relationships. For example, in 5 (iii) x does not
    have <code>rdf:type A</code>, since this is an relationship that is
    covered by the facts that x has <code>rdf:type D</code>, and D is a
    subclass of A. Notice also that the <code>rdf:type B</code> link is also
    removed from the direct graph, for a similar reason. Thus the direct
    graph hides relationships from both the inferred and asserted graphs.
    When displaying instance x in a GUI, particularly in a tree view of some
    kind, the direct graph is often the most useful as it contains the
    useful information in the most compact form.</p>
    <p>
      To list the RDF types of a resource, use:
    </p>
    <pre class="codesample">
listRDFTypes()                 // assumes not-direct
listRDFTypes( boolean direct ) // if direct=true, show only direct relationships</pre>
    <p>
      Related methods allow the <code>rdf:type</code> to be tested, set and returned.
    </p>

    <h2 id="classesBasic">Ontology classes and basic class expressions</h2>

<p> Classes are the basic building blocks of an ontology. A simple class is represented
  in Jena by an <a href="../javadoc/com/hp/hpl/jena/ontology/OntClass.html">OntClass</a>
  object. As I <a href="#rdfPolymorphism">mentioned above</a>, an ontology class
  is a facet of an RDF resource. One way, therefore, to get an ontology class
  is to convert an RDF resource. Assume that <code>m</code> is a suitable defined
  <code>OntModel</code>, into which the ESWC ontology has already been read, and that
  <code>NS</code> is a variable denoting the ontology namespace:
</p>
    <pre class="codesample">
Resource r = m.getResource( NS + "Paper" );
OntClass paper = (OntClass) r.as( OntClass.class );</pre>

<p> This can be shortened by calling <code>getOntClass()</code> on the ontology
  model: </p>
    <pre class="codesample">
OntClass paper = m.getOntClass( NS + "Paper" );</pre>
    <p>The <code>getOntClass</code> method will retrieve the resource with
    the given URI, and attempt to obtain the <code>OntClass</code> facet. If either of
    these operations fail, <code>getOntClass()</code>
    will return null. Compare this with the <code>createClass</code>
    method, which will reuse an existing resource if possible,
    or create a new class resource if not:</p>
    <pre class="codesample">
OntClass paper     = m.createClass( NS + "Paper" );
OntClass bestPaper = m.createClass( NS + "BestPaper" );</pre>
    <p>You can use the create class method to create an anonymous
    class &#150; a class description with no associated URI. Anonymous classes
    are often used when building more complex ontologies in OWL or DAML. They are
    less useful in RDFS.</p>
    <pre class="codesample">
OntClass anonClass = m.createClass();</pre>
    <p>Once you have the ontology class object, you can begin processing
    it through the methods defined on <code>OntClass</code>. The attributes
    of a class are handled in a similar way to the attributes of
    OntResource, above, with a collection of methods to set, add, get, test,
    list and remove values. Properties of classes that are handled in this way
    are:</p>
    <table width="650" border="1" cellspacing="1" cellpadding="1">
      <tr>
        <th width="150">
          Attribute
        </th>
        <th width="500">
          Meaning
        </th>
      </tr>
      <tr>
        <td>subClass</td>
        <td>
            A subclass of this class, i.e. those classes that are declared <code>subClassOf</code> this class.
        </td>
      </tr>
      <tr>
        <td>superClass</td>
        <td>
            A super-class of this class, i.e. a class that this class is a <code>subClassOf</code>.
        </td>
      </tr>
      <tr>
        <td>equivalentClass</td>
        <td>
            A class that represents the same concept as this class. This is not just having the same class extension: the class 'British Prime Minister in 2003' contains the same individual as the class 'the husband of Cherie Blair', but they represent different concepts.
        </td>
      </tr>
      <tr>
        <td>disjointWith</td>
        <td>
            Denotes a class with which this class has no instances in common.
        </td>
      </tr>
    </table>

    <p>
      Thus, in our example ontology, we can print a list the subclasses of an Artefact as follows:
    </p>
    <pre class="codesample">
OntClass artefact = m.getOntClass( NS + "Artefact" );
for (Iterator i = artefact.listSubClasses(); i.hasNext(); ) {
  OntClass c = (OntClass) i.next();
  System.out.println( c.getURI() );
}</pre>
    <p>Note that, under RDFS and OWL semantics, each class is a sub-class of itself
    (in other words, <code>rdfs:subClassOf</code> is reflexive). While this is true,
    under the semantics, Jena users have reported finding it unhelpful. Therefore,
    the <code>listSubClasses</code> and <code>listSuperClasses</code> methods remove
    the reflexive from the list of results returned by the iterator. However, if you
    use the plain <code>Model</code> API to query for <code>rdfs:subClassOf</code>
    triples, assuming that a reasoner is in use, the reflexive triple will appear
    in the deductions model.</p>

    <p>Given an <code>OntClas</code> object, you can create or remove members of
    the class extension &#150; individuals that are instances of the class &#150;
    using the following methods:
    </p>

    <table width="650" border="1" cellspacing="1" cellpadding="1">
      <tr>
        <th width="275">
          Method
        </th>
        <th width="375">
          Meaning
        </th>
      </tr>
      <tr>
        <td>listInstances()<br />listInstances( boolean direct )</td>
        <td>
            Returns an iterator over those instances that include this class among
            their <code>rdf:type</code> values. The <code>direct</code> flag can be
            used to select individuals that are direct members of the class, rather
            than indirectly through the class hierarchy. Thus if <code>p1</code> has
            <code>rdf:type :Paper</code>, it will appear in the iterator returned by
            <code>listInstances</code> on <code>:Artefact</code>, but not in the
            iterator returned by <code>listInstances(false)</code> on <code>:Artefact</code>.
        </td>
      </tr>
      <tr>
        <td>createIndividual()<br />createIndividual( String uri )</td>
        <td>
            Adds a resource to the model, whose asserted <code>rdf:type</code> is
            this ontology class. If no URI is given, the individual is an anonymous
            resource.
        </td>
      </tr>
      <tr>
        <td>dropIndividual( Resource individual )</td>
        <td>
          Removes the association between the given individual and this ontology class.
          Effectively, this removes the <code>rdf:type</code> link between this class
          and the resource. Note that this is not the same as removing the individual
          altogether, unless the only thing that is known about the resource is that
          it is a member of the class. To delete an <code>OntResource</code>, including
          classes and individuals, use the <code>remove()</code> method.
        </td>
      </tr>
    </table>


        <p>To test whether a class is a root of the class hierarchy in this
        model (i.e. it has no known super-classes), call <code>isHierarchyRoot()</code>.</p>
    <p>The domain of a property
    is intended to allow entailments about the class of an individual, given
    that it appears as a statement subject. It is not a constraint that can
    be used to validate a document, in the way that XML schema can do.
    Nevertheless, many developers find it convenient to use the domain of a
    property to document the design intent that the property only applies to
    known instances of the domain class. Given this observation, it can be a
    useful debugging or display aide to show the properties that have this
    class among their domain classes. The method <code>listDeclaredProperties()</code>
    attempts to identify the properties that are intended to apply to
    instances of this class. Using <code>listDeclaredProperties</code> is
    explained in detail in the <a href="../how-to/rdf-frames.html">RDF frames how-to</a>.</p>

    <h2 id="properties">Ontology properties</h2>

    <p>In an ontology, a <em>property</em> denotes the name of a relationship between resources, or between a resource
    and a data value. It corresponds to a predicate in logic representations. One interesting aspect of
    languages like RDFS and OWL is that properties are not defined as aspects of some enclosing
    class, but are first-class objects in their own right. This means that ontologies and ontology-applications
    can store, retrieve and make assertions about properties directly. Consequently, Jena has a set of Java classes
    that allow you to conveniently manipulate the properties represented in an ontology model.</p>
    <p>A property in an ontology model is an extension of the core Jena API class
    <code><a href="../javadoc/com/hp/hpl/jena/rdf/model/Property.html">Property</a></code>,
  and allows access to the additional information that can be asserted about properties
  in an ontology language. The common API super-class for representing ontology properties
  in Java is <code><a href="../javadoc/com/hp/hpl/jena/ontology/OntProperty.html">OntProperty</a></code>.
  Again, using the pattern of add, set, get, list, has, and remove methods, we
  can access the following attributes of an <code>OntProperty</code>: </p>
    <table width="650" border="1" cellspacing="1" cellpadding="1">
      <tr>
        <th width="275">Attribute</th>
        <th width="375">Meaning</th>
      </tr>
      <tr>
        <td>subProperty</td>
        <td>
            A sub property of this property; i.e. a property which is declared to be a <code>subPropertyOf</code> this property. If p is a sub property of q, and we know that <code>A&nbsp;p&nbsp;B</code> is true, we can infer that <code>A&nbsp;q&nbsp;B</code> is also true.
        </td>
      </tr>
      <tr>
        <td>superProperty</td>
        <td>
            A super property of this property, i.e. a property that this property is a <code>subPropertyOf</code>
        </td>
      </tr>
      <tr>
        <td>domain</td>
        <td>
            Denotes the class or classes that form the domain of this property. Multiple domain values are interpreted as a conjunction. The domain denotes the class of value the property maps from.
        </td>
      </tr>
      <tr>
        <td>range</td>
        <td>
            Denotes the class or classes that form the range of this property. Multiple range values are interpreted as a conjunction. The range denotes the class of values the property maps to.
        </td>
      </tr>
      <tr>
        <td>equivalentProperty</td>
        <td>
            Denotes a property that is the same as this property.
        </td>
      </tr>
      <tr>
        <td>inverse</td>
        <td>
            Denotes a property that is the inverse of this property. Thus if q is the inverse of p, and we know that <code>A q B</code>, then we can infer that <code>B p A</code>.
        </td>
      </tr>
    </table>

        <p>In the example ontology, the property <code>hasProgramme</code> has a domain of
        <code>OrganizedEvent</code>, a range of <code>Programme</code> and the human-readable
        label &quot;has programme&quot;.
        I can reconstruct this definition in an empty ontology model as follows:</p>
    <pre class="codesample">
OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
OntClass programme = m.createClass( NS + "Programme" );
OntClass orgEvent = m.createClass( NS + "OrganizedEvent" );

ObjectProperty hasProgramme = m.createObjectProperty( NS + "hasProgramme" );

hasProgramme.addDomain( orgEvent );
body.addRange( programme );
body.addLabel( "has programme", "en" );</pre>

    <p>As a further example, I can alternatively add information to an existing ontology. Let's
    add a super-property <code>hasDeadline</code> to generalise the separate properties denoting
    the submission deadline, notification deadline and camera-ready deadline:</p>
<pre class="codesample">OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
m.read( "http://www.eswc2006.org/technologies/ontology" );

DatatypeProperty subDeadline = m.getDatatypeProperty( NS + "hasSubmissionDeadline" );
DatatypeProperty notifyDeadline = m.getDatatypeProperty( NS + "hasNotificationDeadline" );
DatatypeProperty cameraDeadline = m.getDatatypeProperty( NS + "hasCameraReadyDeadline" );

DatatypeProperty deadline = m.createDatatypeProperty( NS + "deadline" );
deadline.addDomain( m.getOntClass( NS + "Call" ) );
deadline.addRange( XSD.dateTime );

deadline.addSubProperty( subDeadline );
deadline.addSubProperty( notifyDeadline );
deadline.addSubProperty( cameraDeadline );
</pre>
    <p>Note that, although I called the <code>addSubProperty</code> method on the object representing
    the new super-property, the serialized form of the
    ontology will contain <code>rdfs:subPropertyOf</code> axioms on each of the sub-property resources,
    since this is what the language defines. Jena will, in general, try to allow symmetric access to
    sub-properties and sub-classes from either direction.</p>

    <h3 id="propertyTypes">Object and Datatype properties</h3>
    <p>
      OWL and DAML+OIL refine the basic property type from RDF into two sub-types:
      <em>object properties</em> and <em>datatype properties</em>
      (for more details see [<a href="http://www.w3.org/TR/owl-ref/#Property">OWL Reference</a>]).
      The difference between
      them is that an object property can have only individuals in its range, while a datatype
      property has concrete data literals (only) in its range. Some OWL reasoners are able to
      exploit the differences between object and datatype properties to perform more efficient
      reasoning over ontologies. OWL also adds an <em>annotation property</em>, which is defined
      to have no semantic entailments, and so is useful when annotating ontology documents, for example.
    </p>

    <p> In Jena, the Java interfaces
      <code><a href="../javadoc/com/hp/hpl/jena/ontology/ObjectProperty.html">ObjectProperty</a></code>,
      <code><a href="../javadoc/com/hp/hpl/jena/ontology/DatatypeProperty.html">DatatypeProperty</a></code> and
      <code><a href="../javadoc/com/hp/hpl/jena/ontology/AnnotationProperty.html">AnnotationProperty</a></code>
      are sub-types of <code>OntProperty</code>. However, they do not have any behaviours
      (methods) particular to themselves. Their existence allows the more complex
      sub-types of ObjectProperty &#150; transitive properties and so forth &#150; to be kept
      separate in the class hierarchy. However, when you create an object property or datatype property
      in a model, it
      will have the effect of asserting different <code>rdf:type</code> statements
      into the underlying triple store. </p>

    <h3 id="functionalProperties">Functional properties</h3>
    <p>OWL permits object and datatype properties to be <em>functional</em>
      &#150; that is, for a given individual in the domain, the range value will always
      be the same. In particular, if <code>father</code> is a functional property,
      and individual <code>:bryn</code> has <code>father&nbsp;:ijd</code> and <code>father&nbsp;:ian</code>,
      a reasoner is entitled to conclude that <code>:ijd</code> and <code>:ian</code>
      denote the same individual.
      A functional property is equivalent to stating that the property has a maximum
      cardinality of one.</p>
      <p>Being a functional property is represented through the
      <code><a href="../javadoc/com/hp/hpl/jena/ontology/FunctionalProperty.html">FunctionalProperty</a></code>
      facet of an ontology property object. If a property is declared functional
      (test using the <code>isFunctional()</code> method), then the method
      <code>asFunctionalProperty()</code> conveniently returns the functional facet.
      A non-functional property can be made functional through the
      <code>convertToFunctionalProperty()</code> method. When you are creating
      a property object, you also have the option of passing a Boolean parameter
      to the <code>createObjectProperty()</code> method on <code>OntModel</code>.
    </p>

    <h3 id="otherPropertyTypes">Other property types</h3>

    <p> There are several additional sub-types of ObjectProperty that represent additional
      capabilities of ontology properties. A
      <code><a href="../javadoc/com/hp/hpl/jena/ontology/TransitiveProperty.html">TransitiveProperty</a></code>
      means that if p is transitive, and we know <code>:a&nbsp;p&nbsp;:b</code> and also
      <code>b&nbsp;p&nbsp;:c</code>, we can infer that <code>:a&nbsp;p&nbsp;:c</code>. A
      <code><a href="../javadoc/com/hp/hpl/jena/ontology/SymmetricProperty.html">SymmetricProperty</a></code>
      means that if p is symmetric, and we know <code>:a&nbsp;p&nbsp;:b</code>, we can infer
      <code>:b&nbsp;p&nbsp;:a</code>. An
      <code><a href="../javadoc/com/hp/hpl/jena/ontology/InverseFunctionalProperty.html">InverseFunctionalProperty</a></code>
      means that for any given range element, the domain value is unique. (Note that
      in DAML+OIL, the terminology for inverse functional property is <em>unambiguous
      property</em>). </p>

    <p> Given that all properties are <code>RDFNode</code> objects, and therefore
      support the <code>as()</code> method, you can use <code>as()</code> to change
      from an object property facet to a transitive property facet. To make this more
      straightforward, the <code>OntProperty</code> Java class has a number of methods
      that support directly switching to the corresponding facet view: </p>
    <pre class="codesample">public TransitiveProperty asTransitiveProperty();
public FunctionalProperty asFunctionalProperty();
public SymmetricProperty asSymmetricPropery();
public InverseFunctionalProperty asInverseFunctionalProperty();</pre>

    <p> These methods all assume that the underlying model will support this change
      in perspective. If not, the operation will fail with a <code>ConversionException</code>.
      For example, if
      a given property <code>p</code> is not already a transitive property, then invoking
      <code>p.asTransitiveProperty()</code> will throw a conversion exception.
      The following methods will, if necessary, add additional information
      (i.e. the additional <code>rdf:type</code> statement) to allow the conversion
      to an alternative facet to succeed. </p>
    <pre class="codesample">
public TransitiveProperty convertToTransitiveProperty();
public FunctionalProperty convertToFunctionalProperty();
public SymmetricProperty convertToSymmetricPropery();
public InverseFunctionalProperty convertToInverseFunctionalProperty();</pre>

    <p>Finally, methods beginning <code>is...</code> (e.g. <code>isTransitiveProperty</code>)
    allow you to test whether a given property would support a given sub-type facet.</p>

    <h2 id="classesComplex">More complex class expressions</h2>

    <p>I introduced the handling of basic, named classes above.
    These are the only kind of class descriptions
    available in RDFS. In OWL, however, there are a number of
    additional types of class expression, which allow richer and more
    expressive descriptions of concepts. There are two main categories of
    additional class expression: <em>restrictions</em> and <em>Boolean
    expressions</em>. Let's examine each in turn.</p>

    <h3 id="restrictions">Restriction class expressions</h3>

    <p> A <a href="../javadoc/com/hp/hpl/jena/ontology/Restriction.html">restriction</a>
      defines a class by reference to one of the properties of the individuals that
      comprise the members of the class, and then placing some constraint on that property.
      For example, in a simple view of animal taxonomy, we might say that mammals
      are covered in fur, and birds in feathers. Thus the property <code>hasCovering</code>
      is in one case restricted to have the value <code>fur</code>, in the other to
      have the value <code>feathers</code>. This is a <em>has value restriction</em>.
      Six restriction types are currently defined by OWL: </p>

    <table width="650" border="1" cellspacing="1" cellpadding="1">
      <tr>
        <th width="205">Restriction type</th><th width="445">Meaning</th>
      </tr>
      <tr>
        <td>has value</td>
        <td>
            The restricted property has exactly the given value.
        </td>
      </tr>
      <tr>
        <td>all values from</td>
        <td>
            All values of the restricted property, if it has any, are members of the given class.
        </td>
      </tr>
      <tr>
        <td>some values from</td>
        <td>
            The property has at least one value which is a member of the given class.
        </td>
      </tr>
      <tr>
        <td>cardinality</td>
        <td>
            The property has exactly <em>n</em> values, for some positive integer n.
        </td>
      </tr>
      <tr>
        <td>min cardinality</td>
        <td>
            The property has at least <em>n</em> values, for some positive integer n.
        </td>
      </tr>
      <tr>
        <td>max cardinality</td>
        <td>
            The property has at most <em>n</em> values, for some positive integer n.
        </td>
      </tr>
    </table>

    <p>Note that in DAML+OIL terminology, an all-values-from restriction
    is a <em>toClass</em> restriction, while a some-values-from restriction
    is a <em>hasClass</em> restriction. Note also that, at present, the Jena
    ontology API has only limited support for DAML's qualified cardinality
    restrictions (i.e. <code>cardinalityQ</code>, <code>minCardinalityQ</code>
    and <code>maxCardinalityQ</code>). Qualified cardinality restrictions
    are encapsulated in the interfaces <code>CardinalityQRestriction</code>,
    <code>MinCardinalityQRestriction</code> and <code>CardinalityQRestriction</code>.
    <code>OntModel</code> also provides methods for creating and accessing
    qualified cardinality restrictions. Since they are not part of the
    OWL 1.0 language definition, qualified cardinality restrictions are not
    supported in OWL ontologies. Qualified cardinality restrictions may be added
    to the forthcoming OWL 1.1 update, at which point it is likely
    that the Jena ontology API will be updated. Note however, that we are not currently
    making any commitment on the timescale for such an update.</p>

    <p>Jena provides a number of ways of creating restrictions, or
    retrieving them from a model. Firstly, you can retrieve a general restriction
    from the model by its URI, if known.</p>

<pre class="codesample">// get restriction with a given URI
Restriction r = m.getRestriction( NS + "theName" );
</pre>

    <p>You can create a new restriction created by
    nominating the property that the property applies to:</p>
<pre class="codesample">// anonymous restriction on property p
OntProperty p = m.createOntProperty( NS + "p" );
Restriction anonR = m.createRestriction( p );</pre>

    <p>Since a restriction is typically not assigned a URI in an ontology,
    retrieving an existing restriction by name may not be possible. However,
    you can list all of the restrictions in a model and search for the
    one you want:</p>

<pre class="codesample">Iterator i = m.listRestrictions();
while (i.hasNext()) {
    Restriction r = (Restriction) i.next();
    if (isTheOne( r )) {
        // handle the restriction
    }
}</pre>
    <p>A common case is that you want the restrictions on some property <code>p</code>.
    In this case, from an object denoting <code>p</code> you can list the restrictions
    that mention that property:</p>
<pre class="codesample">OntProperty p = m.getProperty( NS + "p" );
Iterator i = p.listReferringRestrictions();
while (i.hasNext()) {
    Restriction r = (Restriction) i.next();
    // now handle the restriction ...
}</pre>

    <p>
      A general restriction can be converted to a specific type of restriction via
      <code>as...</code> methods (if the information is already in the model), or, if
      the information is not in the model, via <code>convertTo...</code> methods.
      For example, to convert the example restriction <code>r</code>
      from the example above to an all values from restriction, you can do the following:
    </p>

    <pre class="codesample">OntClass c = m.createClass( NS + "SomeClass" );
AllValuesFromRestriction avf = r.convertToAllValuesFromRestriction( c );</pre>

    <p>To create a particular restriction <em>ab initio</em>, you can use the creation
      methods defined on <code>OntModel</code>. For example: </p>
<pre class="codesample">OntClass c = m.createClass( NS + "SomeClass" );
ObjectProperty p = m.createObjectProperty( NS + "p" );

// null denotes the URI in an anonymous restriction
AllValuesFromRestriction avf = m.createAllValuesFromRestriction( null, p, c );</pre>

    <p>
      Assuming that the above code fragment was using a model <code>m</code> that was created
      with the OWL language profile, it creates a instance of an OWL restriction that would have
      the following definition in RDF/XML:
    </p>
<pre class="codesample">&lt;owl:Restriction&gt;
  &lt;owl:onProperty rdf:resource="#p"/&gt;
  &lt;owl:allValuesFrom rdf:resource="#SomeClass"/&gt;
&lt;/owl:Restriction&gt;</pre>

    <p>
      Once you have a particular restriction object, there are methods following the
      standard add, get, set and test naming pattern to access the aspects of the restriction.
      For example, in a camera ontology, we might find this definition of a class
      describing Large-Format cameras:
    </p>
<pre class="codesample">&lt;owl:Class rdf:ID="Large-Format"&gt;
  &lt;rdfs:subClassOf rdf:resource="#Camera"/&gt;
  &lt;rdfs:subClassOf&gt;
    &lt;owl:Restriction&gt;
      &lt;owl:onProperty rdf:resource="#body"/&gt;
      &lt;owl:allValuesFrom rdf:resource="#BodyWithNonAdjustableShutterSpeed"/&gt;
   &lt;/owl:Restriction&gt;
  &lt;/rdfs:subClassOf&gt;
&lt;/owl:Class&gt;</pre>

    <p>Here's one way to access the components of the all values from restriction.
    Assume m contains a suitable camera ontology:</p>
<pre class="codesample">OntClass largeFormat = m.getOntClass( camNS + "Large-Format" );
for (Iterator i = LargeFormat.listSuperClasses( true ); i.hasNext(); ) {
  OntClass c = (OntClass) i.next();

  if (c.isRestriction()) {
    Restriction r = c.asRestriction();

    if (r.isAllValuesFromRestriction()) {
      AllValuesFromRestriction av = r.asAllValuesFromRestriction();
      System.out.println( "AllValuesFrom class " +
                          av.getAllValuesFrom().getURI() +
                          " on property " + av.getOnProperty().getURI() );
    }
  }
}</pre>

    <h3 id="booleanClassExprs">Boolean class expressions</h3>
    <p>Most programmers are familiar with the use of Boolean operators
    to construct propositional expressions: conjunction (and), disjunction
    (or) and negation (not). OWL provides a means for
    construction expressions describing classes with analogous operators, by
    considering class descriptions in terms of the set of individuals that
    comprise the members of the class.</p>
    <p>Suppose we wish to say that an
    instance x has <code>rdf:type</code> A <strong>and</strong> <code>rdf:type</code>
    B. This means that x is both a member of the set of individuals in A,
    and in the set of individuals in B. Thus, x lies in the <em>intersection</em>
    of classes A and B. If, on the other hand, A is either has <code>rdf:type</code>
    A <strong>or</strong> B, then x must lie in the <em>union</em> of A and
    B. Finally, to say that x does <strong>not</strong> have <code>rdf:type</code>
    A, it must lie in the <em>complement</em> of A. These operations, union,
    intersection and complement are the Boolean operators for constructing
    class expressions. While complement takes only a single argument, union
    and intersection must necessarily take more than one argument. Before
    continuing with constructing and using Boolean class expressions, I
    digress briefly to discuss lists.</p>

    <h3 id="listExpressions">List expressions</h3>
    <p>
      RDF originally had three container types: <code>Seq</code>,
      <code>Alt</code> and <code>Bag</code>. While useful, these are
      all open forms: it is not possible to say that a given container has a fixed number
      of values. The DAML+OIL standard introduced a fourth container type - lists - in
      order to have a closed collection. Lists have subsequently been added to the core RDF
      specification, and are used extensively in OWL.
      A list follows the well-known <em>cons cell</em> pattern from Lisp, Prolog and other
      list-handling languages. Each cell of a list is either the end-of-list terminator
      (<code>nil</code> in Lisp), or is a pair consisting of a value and a pointer to the
      cell that is the first cell on the tail of the list. In RDF lists, the end-of-list is
      marked by a resource with name <code>rdf:nil</code>, while each list cell is an anonymous
      resource with two properties, one denoting the tail and the other the value.
      Fortunately, this complexity is hidden by some simple syntax:
    </p>
<pre class="codesample">&lt;p rdf:parseType="collection"&gt;
  &lt;A /&gt;
  &lt;B /&gt;
&lt;/p&gt;</pre>
    <p>
      According to the RDF specification, this list of two elements has the
      following expansion as RDF triples:
    </p>
<pre class="codesample">&lt;p&gt;
  &lt;rdf:first&gt;&lt;A /&gt;&lt;/rdf:first&gt;
  &lt;rdf:rest&gt;
    &lt;rdf:first&gt;&lt;B /&gt;&lt;/rdf:first&gt;
    &lt;rdf:rest rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"/&gt;
  &lt;/rdf:rest&gt;
&lt;/p&gt;</pre>
<p>Given this construction, a well formed list (one with
exactly one <code>rdf:first</code> and <code>rdf:rest</code> per cons
cell) has a precisely determined set of members. Incidentally, the
same list in N3/Turtle is even more compact:</p>
<pre class="codesample">:example
    :p ( :A :B ).</pre>

<p> Although lists
  are defined in the generic RDF model in Jena, they are extensively used by the
  ontology API so I mention them here. Full details of the methods defined on
  the <a href="../javadoc/com/hp/hpl/jena/rdf/model/RDFList.html"><code>RDFList</code></a>
  class are available in the Jena Javadoc. </p>

<p> A number of means of constructing lists is defined in
<a href="../javadoc/com/hp/hpl/jena/rdf/model/Model.html"><code>Model</code></a>,
  as variants on <code>createList</code>. For example, you can construct
  a list of three classes as follows: </p>
    <pre class="codesample">OntModel m = ModelFactory.createOntModel();
OntClass c0 = m.createClass( NS + "c0" );
OntClass c1 = m.createClass( NS + "c1" );
OntClass c2 = m.createClass( NS + "c2" );

RDFList cs = m.createList( new RDFNode[] {c0, c1, c2} );</pre>
    <p>
      Alternatively, you can build a list one element at at time:
    </p>
    <pre class="codesample">OntModel m = ModelFactory.createOntModel();
RDFList cs = m.createList(); // Cs is empty
cs = cs.cons( m.createClass( NS + "c0" ) );
cs = cs.cons( m.createClass( NS + "c1" ) );
cs = cs.cons( m.createClass( NS + "c2" ) );</pre>

    <p>Note that these two approaches end with the classes in the lists
    in opposite orders, since the <code>cons</code> operation adds a new
    list cell to the front of the list. Thus the second list will run c2 to
    c0. In the ontology operations we are discussing here, the order of
    values in the list is not considered significant.</p>

    <p>Once the list has been constructed or obtained from the model (a
    resource which is a cell in a list sequence will accept <code>.as(&nbsp;RDFList.class&nbsp;)</code>),
    <a href="../javadoc/com/hp/hpl/jena/rdf/model/RDFList.html"><code>RDFList</code></a>
    methods may be used to access members of the list, iterate over
    the list, and so forth. For example:</p>

<pre class="codesample">System.out.println( "List has " + myRDFList.size() + " members:" );
for (Iterator i = myRDFList.iterator(); i.hasNext(); ) {
  System.out.println( i.next() );
}</pre>

<!--  watermark ... edit pass has got to here -->
    <h3 class="booleanExprs">Intersection, union and complement class expressions</h3>

    <p>Given Jena's ability to construct lists, building intersection and union
    class expressions is straightforward. The <code>create</code> methods on OntModel
    allow an intersection or union class to be built directly.
    Alternatively, given an existing OntClass, the convertTo methods can be
    used to construct facet representing the more specialised expressions.
    For example, the camera ontology defines an SLR camera as the
    intersection of the class Camera with a has value restriction on the
    viewFinder property to have the value ThroughTheLens. Here's the XML
    declaration:</p>
<pre>
&lt;owl:Class rdf:ID="SLR"&gt;
  &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
    &lt;owl:Class rdf:about="#Camera"/&gt;
    &lt;owl:Restriction&gt;
      &lt;owl:onProperty rdf:resource="#viewfinder"/&gt;
      &lt;owl:hasValue rdf:resource="#ThroughTheLens"/&gt;
    &lt;/owl:Restriction&gt;
  &lt;/owl:intersectionOf&gt;
&lt;/owl:Class&gt;</pre>
    <p>
      and here is code to reproduce this example from scratch:
    </p>
    <pre>
// create the throughTheLens window instance
OntClass Window = m.createClass( camNS + "Window" );
Individual throughTheLens = m.createIndividual( camNS + "ThroughTheLens", Window );

// create the viewfinder property
ObjectProperty viewfinder = m.createObjectProperty( camNS + "viewfinder"    );

// now the anonymous hasValue restriction
HasValueRestriction viewThroughLens =
                      m.createHasValueRestriction( null, viewfinder, throughTheLens );

// class Camera
OntClass Camera = m.createClass( camNS + "Camera" );

// finally create the intersection class to define SLR
IntersectionClass SLR = m.createIntersectionClass( camNS + "SLR",
                      m.createList( new RDFNode[] {viewThroughLens, Camera} ) );</pre>

<p> Given the commonality between union and intersection class expressions, rather
  than separate methods to set the components of the expression, we have defined
  a common super-class <code><a href="../javadoc/com/hp/hpl/jena/ontology/BooleanClassDescription.html">BooleanClassDescription</a></code>.
  This uses the terminology of <em>operands</em> to the expression. In the above
  example, the operands are the Camera class and the has value restriction. The
  <code>BooleanClassDescription</code> class allows the operands to be set <em>en
  masse</em> by supplying the list, or to be added or deleted one at a time. </p>
    <p>
      Complement class expressions are very similar in many ways. The principal difference is that they take only a single class as operand, and therefore do not accept a list of operands.
    </p>
    <h3>
      Enumerated classes
    </h3>

<p> The final type class expression introduced by OWL and DAML is the enumerated
  class. Recall that a class is a set of individuals. Often the members of the
  class are defined <em>implicitly</em>: for example, "the class of intelligent
  sheep". Monty Python fans will recognise that this class is non-empty, but there
  may be other intelligent sheep and in any case we do not know Eric's URI. Sometimes
  it is convenient to define a class <em>explicitly</em>, by listing the individuals
  it contains. An <em><a href="../javadoc/com/hp/hpl/jena/ontology/EnumeratedClass.html">enumerated
  class</a></em> is exactly the class whose members are the given individuals.
  For example, we know that the class of PrimaryColours contains exactly red,
  green and blue, and no others. </p>
    <p>
      In Jena, an enumerated class is created in a similar way to other classes. The set of values that comprise the enumeration is described by an RDFList.
    </p>
    <p>
      In the camera ontology, the class Viewer is defined as either through the lens or window on top of camera:
    </p>
    <pre>
&lt;owl:Class rdf:ID="Viewer"&gt;
  &lt;owl:oneOf rdf:parseType="Collection"&gt;
    &lt;camera:Window rdf:about="#ThroughTheLens"/&gt;
    &lt;camera:Window rdf:about="#WindowOnTopOfCamera"/&gt;
  &lt;/owl:oneOf&gt;
&lt;/owl:Class&gt;</pre>
    <p>
      To list the contents of this enumeration, we could do the following:
    </p>
    <pre>
EnumeratedClass Viewer = m.getEnumeratedClass( camNS + "Viewer" );
for (Iterator i = Viewer.getOneOf().iterator(); i.hasNext(); ) {
  Resource r = (Resource) i.next();
  System.out.println( "- " + r.getLocalName() );
}</pre>
    <h3>
      Listing classes
    </h3>

<p> In many applications, there is a need to inspect the set of classes in an
  ontology. The listXXX methods on <code>OntModel</code> provide a variety of
  means of listing types of class. The methods available are: </p>
    <pre>
public ExtendedIterator listClasses();
public ExtendedIterator listEnumeratedClasses();
public ExtendedIterator listUnionClasses();
public ExtendedIterator listComplementClasses();
public ExtendedIterator listIntersectionClasses();
public ExtendedIterator listNamedClasses();
public ExtendedIterator listRestrictions();</pre>
    <p>
      Note that, particularly when the underlying store is a database, it is important to close the iterator, so that any state (e.g. the database connection resources) can be released. Closing happens automatically when the <code>hasNext()</code> method on the iterator returns false. If the client code does not iterate all the way to the end of the iterator, the <code>close()</code> method should be called explicitly. Note also that the values returned by these iterators will depend on the asserted data and the reasoner being used. For example, if the model contains a Restriction, that restriction will only be returned by the listClasses() iterator if the model is bound to a reasoner that can infer that, since <code>Restriction</code> is a subClassOf <code>Class</code>, any restriction must also be a class. This difference can be exploited by the programmer: to list classes and restrictions separately, perform the <code>listClasses()</code> and <code>listRestictions()</code> methods on the base model only, or on a model with no reasoner attached.
    </p>
    <h2 id="instances">
      Instances (individuals)
    </h2>

<p> In OWL Full, and in DAML+OIL, any value can be an individual - and thus the
  subject of properties in the graph other than language definition declarations.
  In OWL Lite and DL, the language terms and the instance data that the application
  is working with are kept separate (by definition of the language). Jena therefore
  supports a simple notion of an <a href="../javadoc/com/hp/hpl/jena/ontology/Individual.html"><code>Individual</code></a>,
  which is essentially an alias for Resource. However, we expect that typical
  uses will be to create individuals that are instances of user-defined classes.
</p>
    <p>
      Thus the means of creating a new individual via the OntModel requires the class to which the individual will initially belong:
    </p>
    <pre>
OntClass c = m.createClass( Ns + "C" );
Individual inst = m.createIndividual( Ns + "foo", c );</pre>
    <p>
      In the above example, the individual is named, but this is not necessary. The method <code>createIndividual(&nbsp;Resource cls&nbsp;)</code> creates an anonymous individual belonging to the given class. Note that the type of the class parameter is only <code>Resource</code>. It is not required to use <code>As()</code> to morph a <code>Resource</code> to an <code>OntClass</code> before calling this method, though of course an <code>OntClass</code> is a <code>Resource</code> so using an <code>OntClass</code> will work perfectly well. This design choice was taken to allow programmers flexibility in not having to pre-convert a class resource to an appropriate type. However, the cost of this flexibility is that it is the responsibility of the programmer to make sure that the resource passed as a class is a sensible value.
    </p>
    <p>
      The only additional methods that an individual provides is the standard collection of method for manipulating the <code>sameIndividualAs</code> attribute. In OWL, this is an alias for <code>owl:sameAs</code>, and, as such, may be removed from the standard to reduce redundancy.
    </p>
    <h2 id="metadata">
      Ontology meta-data
    </h2>

<p> In OWL and DAML+OIL, meta-data about the ontology itself is attached
  as properties to an
  individual of class <code>owl:Ontology</code> or <code>daml:Ontology</code> as appropriate.
  By convention, the URI of this individual is the URI of the ontology document itself. In the XML serialisation, this
  is typically shown as: </p>
    <pre>
&lt;owl:Ontology rdf:about=""&gt;
&lt;/owl:Ontology&gt;</pre>

<p>Note that the construct <code>rdf:about=&quot;&quot;</code> does <em>not</em>
  indicate a resource with no URI; it is in fact a shorthand way of referencing
  the <em>base URI</em> of the document containing the ontology. The base URI
  may be stated in the document through an <code>xml:base</code> declaration
  in the XML preamble, or can be specified when reading the document via
  Jena's Model API.</p>

<p>Various meta-data statements are typically attached to this object, to indicate
  attributes of the ontology as a whole. The Java object Ontology represents this
  special instance, and uses the standard add, set, get, list, test and delete
  pattern to provide access to the following attributes: </p>
    <table width="487" border="1" cellspacing="1" cellpadding="1">
      <tr>
        <th width="179">
          Attribute
        </th>
        <th width="295">
          Meaning
        </th>
      </tr>
      <tr>
        <td width="179">
          <div align="left">
            backwardCompatibleWith
          </div>
        </td>
        <td width="295">
          <div align="left">
            Names a prior version of this ontology that this version is compatible with.
          </div>
        </td>
      </tr>
      <tr>
        <td width="179">
          <div align="left">
            incompatibleWith
          </div>
        </td>
        <td width="295">
          <div align="left">
            Names a prior version of this ontology that this version is not compatible with
          </div>
        </td>
      </tr>
      <tr>
        <td width="179">
          <div align="left">
            priorVersion
          </div>
        </td>
        <td width="295">
          <div align="left">
            Names a prior version of this ontology.
          </div>
        </td>
      </tr>
      <tr>
        <td width="179">
          <div align="left">
            imports
          </div>
        </td>
        <td width="295">
          <div align="left">
            Names an ontology whose definitions this ontology imports
          </div>
        </td>
      </tr>
    </table>
    <p>
      In addition to these attributes, the Ontology element typically contains standard meta-data properties, such as comment, label and version info.
    </p>
<p>
  In the Java API, the ontology's metadata properties can be accessed through
  the
  <a href="../javadoc/com/hp/hpl/jena/ontology/Ontology.html"><code>Ontology</code></a>
  interface.  Suppose we wish to know the list of URI's that the ontology imports.
  First we must obtain the resource representing the ontology itself.
  </p>
<pre>
String base = ....; // the base URI of the ontology
OntModel m = ....;  // the model containing the ontology statements
Ontology ont = m.getOntology( base );

// now list the ontology imports
for (Iterator i = ont.listImports(); i.hasNext(); ) {
    System.out.println( &quot;Ontology &quot; + base + &quot; imports &quot; + i.next() );
}</pre>

<p>If the base URI of the ontology is not known, all resources of <code>rdf:type</code>
<code>Ontology</code> in a given model can be listed by <code>OntModel.listOntologies()</code>.
If there is only one of these, it is safe to assume that it is <em>the</em> Ontology
resource for the ontology. However, it should be noted that if more than one ontology document
has been read in to the model (for example by including the imports of a document), there may
well be more than one <code>Ontology</code> resource in the model.
</p>
    <p>
      A common practice is also to use the Ontology element to attach Dublin Core
      metadata to the ontology document. Jena provides a copy of the Dublin Core
      vocabulary, in <code>com.hp.hpl.jena.vocabulary.DC</code>. To attach a statement saying
      that the ontology was authored by John Smith, we can say:
    </p>
    <pre>
Ontology ont = m.getOntology( baseURI );
ont.addProperty( DC.creator, "John Smith" );</pre>
<p>It is also possible to programatically add imports and other meta-data to a
model, for example:</p>
<pre>
String base = ....; // the base URI of the ontology
OntModel m = ....;

Ontology ont = m.createOntology( base );
ont.addImport( m.createResource( "http://example.com/import1" ) );
ont.addImport( m.createResource( "http://example.com/import2" ) );</pre>

<p>Note that under default conditions, simply adding (or removing) an <code>owl:imports</code>
statement to a model will not cause the corresponding document to be imported (or removed).
However, by calling <code>OntModel.setDynamicImports(true)</code>, the model will start
noticing the addition or removal of <code>owl:imports</code> statements. The same holds
for <code>daml:imports</code> in DAML ont models.</p>

<h2 id="inferenceIntro"> Ontology inference: overview</h2>
<p>It is not necessary to use the Ontology API with Jena's reasoning capability
  turned on. In general, the reasoners will add information to the ontology model
  that it is not useful for the application to see. A good example is an ontology
  editor. Here, the user should typically be presented only with the information
  they have entered in to their ontology; the addition of the entailed information
  into the editor's display would be very confusing. Since Jena does not currently
  have a means for distinguishing inferred statements from those statements asserted
  into the base model, a typical good choice for ontology editors is to run with
  no reasoner.</p>
<p>In many other cases, however, it is the addition of the reasoner that makes
  the ontology useful. For example, if we know that John is the father of Mary,
  we would expect a 'yes' if we ask if John is the parent of Mary. The parent
  relationship is not asserted, but we know (from our ontology) that <code>fatherOf</code>
  is a sub-property of <code>parentOf</code>. If 'John fatherOf Mary' is true,
  then 'John parentOf Mary' is also true. It is precisely this kind of interpretation
  (including much more complicated entailments) that we have provided inference
  support in Jena.</p>
<p>For a complete and thorough description of Jena's inference capabilities, please
  see the <a href="../inference/index.html">reasoner documentation</a>. This section
  of of the ontology API documentation is intended to serve as only a brief guide
  and overview.</p>
<p>The reasoner attached to an ontology model, if any, is specified by the
<a href="../javadoc/com/hp/hpl/jena/ontology/OntModelSpec.html"><code>OntModelSpec</code></a>.
  The methods <code>setReasoner</code> and <code>setReasonerFactory</code> are
  used to specify a reasoner. The setReasoner variant is intended for use on a
  specification which will only be used to build a single model. The factory variant
  is used where the OntModelSpec will be used to build more than one model, ensuring
  that each model gets its own reasoner object. The ReasonerRegistry provides
  a collection of pre-built reasoners (see the reasoner documentation for more
  details). However, it is also possible for advanced users to define their own
  reasoner that conforms to the appropriate interface. In particular, a future
  version of Jena will provide adapters to freely available reasoning tools, that
  may be highly optimised for certain ontology reasoning tasks (such as instance
  classification or consistency checking). </p>
<p>To facilitate the choice of reasoners for a given model, some common choices
  have been included in the pre-built ontology model specifications available
  as static fields on <code>OntModelSpec</code>. The current choices (correct
  at the time of writing, but the JavaDoc should always be taken as the definitive
  guide) are:</p>
<table width="512" border="1" cellspacing="0" cellpadding="1">
  <tr>
    <th width="158">OntModelSpec field</th>
    <th width="344">Description</th>
  </tr>
  <tr>
    <td width="158"><em><code>xxx</code></em><code>_TRANS_INF</code></td>
    <td width="344">
      <div align="left">Uses the transitive reasoner, a very simple inference
        component that can produce the transitive closure of the class and property
        hierarchies. </div>
    </td>
  </tr>
  <tr>
    <td width="158"><em><code>xxx</code></em><code>_RDFS_INF</code></td>
    <td width="344">
      <div align="left">Uses a rule-based reasoner with the RDFS entailment rules.
        This includes the entailments of the transitive reasoner, with additional
        RDFS entailments (include domain and range, for example) as well. See
        the reasoner documentation for choices on control parameters for this
        reasoner.</div>
    </td>
  </tr>
  <tr>
    <td width="158"><em><code>xxx</code></em><code>_RULE_INF</code></td>
    <td width="344">
      <div align="left">Uses a rule-based reasoner with a suitable set of semantic
        rules for the language specified in the xxx part of the name. This is
        most complete for OWL (though restricted to a subset of OWL close to OWL-lite).
        A small DAML ruleset is also defined that has a capability similar to
        that of the Jena 1 DAML API, but with improved performance and robustness.
        A recommended reasoner for OWL is the MICRO_RULE_INF setting, which
        is a reasoner that attempts to make a useful trade-off between semantic
        completeness and computational efficiency.</div>
    </td>
  </tr>
  <tr>
    <td width="158"><em>no inf</em></td>
    <td width="344">
      <div align="left">A model specification with no reasoner defined.</div>
    </td>
  </tr>
</table>
<p>Depending on which of these choices is made, the statements returned from queries
  to a given ontology model may vary considerably.</p>
<h3>Additional notes</h3>
<p>Jena's inference machinery defines some specialised services that are not exposed
  through the addition of extra triples to the model. These are exposed by the
  <a href="../javadoc/com/hp/hpl/jena/rdf/model/InfModel.html"><code>InfModel</code></a>
  interface; for convenience OntModel extends this interface to make these services
  directly available to the user. Please note that calling inference-specific
  methods on an ontology model that does not contain a reasoner will have unpredictable
  results. Typically these methods will have no effect or return null, but this
  behaviour should not be relied on the user.</p>
<p>In general, inference models will add a lot of additional statements to a given
  model, including the axioms appropriate to the ontology language. This is typically
  not something that should be output when the model is serialize, so <em><code>write()</code>
  on an ontology model will only write the asserted statements from the base model.</em>
  This is typically the correct behaviour, but there are occasions (e.g. during
  debugging) when we may want to write the entire model, virtual triples included.
  The easiest way to achieve this is to construct a temporary plain model, containing
  the contents of the ontology model:</p>
<pre>OntModel om = ...

// write all of om contents to stderr for debugging
Model plain = ModelFactory.createModelForGraph( om.getGraph() );
plain.write( System.err, &quot;RDF/XML-ABBREV&quot; );</pre>
<p>See also the note on <a href="common-problems.html#aBox-tBox">combining a-box and t-box
  data</a> using the OntModel.</p>

    <h2 id="legacyDAML">Working with DAML+OIL ontologies</h2>
    <p><strong>Jena 2.5 update</strong> With effect from release 2.5 of Jena,
    the legacy DAML+OIL API will be deprecated, and it is scheduled to be
    removed from Jena in time for the 2.6 release. The effect of this is
    that users of DAML+OIL using the legacy API (i.e. the classes in
    <code>com.hp.hpl.jena.ontology.daml</code>) should move their projects
    either to work with OWL, or at least to work with the DAML+OIL profile
    of the standard <code>OntModel</code>. The DAML+OIL <code>OntModel</code>
    profile will continue to be supported for the currently forseen future.
    <br /><em>End of Jena 2.5 update</em>.</p>
<p>Generally speaking, it is recommended that developers who want to work on Semantic
  Web applications should use RDFS, or <a href="http://www.w3.org/2004/OWL/">OWL</a>,
  as their ontology language. OWL has had the benefit of a more rigorous design
  and significant input to its design from researchers with deep experience
  in building inference engines. Nevertheless, there remains some legacy
  ontology data on the Semantic Web today encoded in <a href="http://www.daml.org">DAML+OIL</a>,
  the precursor to OWL. Jena 2 currently fully supports ontology processing in
  DAML+OIL as well as OWL and RDFS. However, support for DAML+OIL may be
  reduced or removed in future releases of Jena.</p>
<p>For new Jena users, and those who have the opportunity to adapt their existing
  code, the new ontology API (as described in the bulk of this document) is the
  recommended route for processing DAML data. Using the language profile, the
  ontology API can handle RDFS, OWL and DAML sources with equal ease. Thus, OntClass
  can be used to represent a DAML class, an OWL class or an RDFS class.</p>
<p>For existing Jena 1.x users migrating to Jena 2, we have also provided a re-implementation
  of the Jena 1 DAML API in Jena 2. This provides abstractions such as DAMLModel,
  DAMLClass, DAMLProperty and so forth. <strong>Note</strong> that we recommend
  the use of this legacy API <em>only</em> for porting Jena 1 code (see Jena 2.5
  note, above). Future versions
  of Jena beyond the 2.6 release <strong>will not include the legacy DAML API</strong>.
  Note that the port of the legacy
  API is essentially a set of convenience wrappers onto the new architecture,
  so there should be little or no computational advantage to using the DAML API
  over the generic ontology API.</p>
<p>For existing users, the Jena 1 class structure from <code>com.hp.hpl.jena.daml</code>
  has been retained, but renamed to package <code>com.hp.hpl.jena.ontology.daml</code>.
  There are a number of differences that will need to be taken into account however.
  These include:</p>
<ul>
  <li>use of the DAML xxxImpl classes is strongly advised against. In Jena 1, an
    ontology model was created with <code>new&nbsp;DAMLModelImpl()</code>. This
    should be changed to <code>ModelFactory().createDAMLModel()</code>. In all
    other cases, directly constructing the <code>Impl</code> classes should be
    avoided. In Jena2, there are few if any cases where the solution to a programming
    problem is to directly use the <code>Impl</code> classes.</li>
  <li>the abstraction classes are not automatically created at model load time.
    In Jena 1, during the process of loading a DAML model, the API would make
    an attempt to determine which abstraction class (DAMLClass, DAMLObjectProperty,
    etc) was the correct one to use to represent a given resource. While this
    was sometimes convenient, it had severe limitations. In Jena 2, we use resource-level
    polymorphism, including the <code>.as()</code> mechanism, to allow different abstractions
    to represent different facets of a resource. These facets are created on demand,
    rather than at load-time. Thus, for example, users should not expect that
    a resource representing a DAML class will automatically be <code>instanceof&nbsp;DAMLClass</code>.</li>
</ul>

<h2 id="persistence">Working with persistent ontologies</h2>
<p>A common way to work with ontology data is to load the ontology
  axioms and instances at run-time from a set of source documents. This is a very
  flexible approach, but has limitations. In particular, it requires the documents
  to be parsed each time the application is run. For large ontologies, this can
  be a source of significant overhead. Jena provides an implementation of the
  RDF model interface that stores the triples persistently in a database. This
  saves the overhead of loading the model each time, and means that RDF models
  significantly larger than the computer's main memory can be stored, but at the
  expense of a higher overhead (a database interaction) to retrieve and update
  RDF data from the model. This section shows how to use the ontology API with
  Jena's persistent database models.</p>
<p>For information on setting-up and accessing the database models
  themselves, see the <a href="../DB/index.html">DB documentation</a>. We do not
  cover this aspect in this section.</p>
<p>There are two somewhat separate requirements for persistently
  storing ontology data. The first is making the main or base model itself persistent.
  The second is re-using or creating persistent models for the imports of an ontology.
  These two requirements are handled slightly differently. A simple, but complete,
  example of using persistent database models for storing ontologies can be found
  <a href="../examples/persistent-ont-model/index.html">here</a>.</p>
<p>To retrieve a model from the database, it has to be named.
  Fortunately, common practice for ontologies on the Semantic Web is that each
  is named with a URI. We use this URI to name the model that is stored in the
  database. Note carefully what is actually happening here: we are exploiting
  a feature of the database sub-system to make persistently stored ontologies
  easy to retrieve, but we are not in any sense resolving the URI of the model.
  Once placed into the database, the name of the model is treated as an opaque
  string.</p>
<p>Thus to create a persistent model for the ontology <code>http://example.org/Customers</code>,
  we create a model maker that will access our underlying database, and use the
  ontology URI as the database name. We then take the resulting persistent model,
  and use it as the base model when constructing an ontology model:</p>
<pre>Model base = getMaker().createModel( "http://example.org/Customers" );
OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_RULE_INF, base );</pre>
<p></p>
<p>Here we assume that the <code>getMaker()</code> method returns a suitably initialized<code>ModelMaker</code>
  that will open the connection to the database. This step only creates a persistent
  model named with the ontology URI. To initialise the content, we must either
  add statements to the model using the OntModel API, or do a one-time read from
  a document:</p>
<pre>m.read( "http://example.org/Customers" );</pre>
<p>Once this step is completed, the model contents may be accessed in future without
  needing to read again.</p>
<p>If the Customers ontology imports other ontologies, using owl:imports or daml:imports,
  the Jena Ontology API will build a union model containing the closure of the
  imports. Even if the base model is persistent, by predefined OntologySpec objects
  only specify memory models to contain the imported ontologies, since memory
  models do not require any parameters.</p>
<p>To specify that the imported models should stored in, and retrieved from, the
  database, we must update the ontology spec object to use the model maker that
  encapsulates the database connection:</p>
<pre>OntModelSpec spec = new OntModelSpec( OntModelSpec.OWL_MEM_RULE_INF );
spec.setModelMaker( getMaker() );</pre>
<p>This new model maker will then be used to generate persistent models named
  with the URI of the imported ontology, if it passed instead of OntModelSpec.OWL_MEM_RULE_INF
  to the createOntologyModel method of the model factory. Note that once the import
  has been loaded once into the database, it can be re-used by other ontologies
  that import it. Thus a given database will only contain at most one copy of
  each imported ontology.</p>
<p>A <a href="../examples/persistent-ont-model/index.html">sample program</a> shows
  both of the above steps combined, to create an ontology in which both base model
  and imports are stored in a persistent database.</p>
</body>
</html>
