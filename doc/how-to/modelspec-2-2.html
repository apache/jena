<html>
<head>
<title>ModelSpec 2.2 howto</title>
<style>
p.note {
    background-color: #eef;
    }
pre {
    background-color: #eee;
    margin-top: 2mm;
    margin-bottom: 2mm;
    margin-left: 5mm;
	margin-right: 5mm
    }
<link href="../styles/doc.css" rel="stylesheet" type="text/css">
</style>
</head>
<body>
<h1>ModelSpec howto - describing Jena 2.2 models in RDF</h1>

<i>draft for discussion 17th August 2004</i>
<br><i>version 0.4</i>

<h1>introduction</h1>

This document describes the ModelSpec features for Jena 2.2 (although
they will be available in CVS before Jena 2.2 is released). They build
on the experimental features available in Jena 2.0 and 2.1, but have
been extended to increase flexibility and uniformity.

<p>The intention is to be able to specify how a model is constructed 
using a configuration file, input stream, URL, or other way of getting 
RDF into a Jena process, and for this configuration to be capable of
specifying anything that the ModelFactory class can construct.

<p>A more formal document is available: the 
<a href="modelspec-details-2-2.html">ModelSpec design document</a>. 
Here we concentrate on how to use ModelSpecs in general.

<p>The ModelSpec descriptions use the Jena Model Specification
vocabulary, which is available in the vocabulary class <code>JMS</code>
and which will be referred to using the prefix <code>jms</code>.
Jena defines this vocabulary namespace as 

<blockquote>
http://jena.hpl.hp.com/2003/08/jms#
</blockquote>

<h1>differences from the original ModelSpecs</h1>

The revised ModelSpec differs from the original in several minor ways
and a few major ones, those being:

<ul>
<li>the additional of specifications for rulesets and schemas.

<li>the separation out of database connection specifications.

<li>the special type <code>Shared</code> to allow values to be
    shared by specifications.

</ul>


<h1>creating a ModelSpec</h1>

<code>ModelSpec</code>s are created by calling one of the ModelFactory 
methods named <code>createSpec</code>, which create a ModelSpec from
an RDF description. There are four variants of <code>createSpec</code>:

<ul>
<li>createSpec( Resource r , Model m ). This is the core method.
    The ModelSpec is created from the sub-graph of <code>m</code>
	rooted at <code>r</code>. The resource <code>r</code> identifies
	the model specification. Model specifications are described in
	detail in [A LATER SECTION].

<li>createSpec( Model m ). The ModelSpec is created from the sub-graph
    of <code>m</code> rooted at the unique resource with type
	<code>jms:ModelSpec</code>.

<li>createSpec( Resource r ). This abbreviates 
    <code>createSpec( r, r.getModel() )</code>.

</ul>

All ModelSpecs are interpreted using RDFS inference with respect to the
JMS schema found at <b>reference</b> and also in the JMS vocabulary
class <b>full name</b>.

<h1>using a ModelSpec</h1>

A ModelSpec doesn't describe a single model, but a way of making
many models of the same kind. Often these models are named, or built
on named models. The two important creation methods are:

<ul>
<li><code>createModel()</code>: create a new model according to
    the specification. This method is used by 
	<code>ModelFactory.createModel(ModelSpec)</code>. You may need
	to cast this model to the appropriate type - in particular,
	if you're expecting an <code>OntModel</code>.
	
	<p class=note>[Should we provide createOntModel and createInfModel as
	wrappers for these cases?]

<li><code>createModelOver(String name)</code>: most <code>ModelSpec</code>s
    have an underlying <a href="../javadoc/com/hp/hpl/jena/rdf/model/ModelMaker.html">
    <code>ModelMaker</code></a>. This method creates a new Model where
    any underlying Model has the given <code>name</code> in that ModelMaker.
    For particularly simple <code>ModelSpec</code>s, the result is that
    Model. The usual case of interest is when the ModelSpec creates
	models in a database.
</ul>

Once a ModelSpec has been constructed, the RDF on which it is based
may become inacessible; indeed, it is possible to construct some
ModelSpecs without using RDF at all. To regenerate RDF "equivalent"
to that description, use:

<ul>

<li><code>getDescription()</code>: returns an RDF description which
    describes this ModelSpec. If the original RDF description had no
    superfluous statements, this model is likely "the same" as that
    original, ie isomorphic. This is a useful way to save an RDF
    description to be used in a later <code>createSpec</code>.

</ul>

<h1>Some simple ModelSpec descriptions</h1>

We will write our descriptions in N3, rather than RDF/XML, for clarity.
We will assume the usual Jena prefixes (rdfs, jms, rdf), call the
root resource of the description "_:this", and make heavy use of
bnodes. Your own descriptions can use whatever mixtures of bnodes
and URIs you like.
 
<h2>PlainModelSpec, no frills</h2>

A ModelSpec for plain [non-reasoning], default models can be as 
simple as

<pre>
_:this rdf:type jms:DefaultModelSpec .
</pre>

This will construct a default model (ie the same kind of
Model that <code>ModelFactory.createDefaultModel()</code>
will construct). If anything more complicated that this is
required, then a <i>model maker</i> must be specified. 

<pre>
_:this jms:maker _:maker .
</pre>

It happens that this specificiation, where a model maker is
identified but not further described, also produces a ModelSpec
that makes default models. Pick whichever you find most pleasing.

<p>If you wish to create models with different <i>reification styles</i>,
then the maker can specify the style explicitly.

<pre>
_:this jms:maker _:maker .
_:maker jms:reificationStyle jms:rsMinimal .
</pre>

This will produce models which have the <i>minimal</i> reification
style. (For an explanation of the different styles, see <b>THAT DOCUMENT</b>.

<p class=note>This fragment may disappear if we can eliminate reification styles
completely.])

<h2>PlainModelSpec, file-based</h2>

You can specify a model that is loaded from, and written back
to, some file using a FileModelMaker. The model is loaded from
the file when it is created, and written back when it is
closed. The <code>fileBase</code>, the directory in which the
file is found, has to be specified.

<pre>
_:this jms:maker _:maker .
_:maker jms:fileBase "/tmp" .
</pre>

Filing-system names are of course implementation-specific,
so if you expect to move <code>fileBase</code>-using ModelSpecs
between systems, take care.

<p>A file-based ModelSpec can use <code>createModelOver(String s)</code>
to create models loaded from the file whose name is <code>s</code>
within the <code>fileBase</code>. If the file does not exist, the
model will initially be empty, but will be written back when closed.

<p>Of course, a refication style can be specified as well as a
filebase. There is no need for a file-based model to be opened
with the same style each time it is used - the reification style 
is not preserved.

<h2>PlainModelSpec from a database</h2>

A Plain (ie non-inferring, non-ontologogical) model can be a
persistent database model. Jena supports JDBC-connected database models;
these are specified using an RDB model-maker. Each such model created
will use it's own database connection.

<pre>
_:this jms:maker _:maker .
_:maker jms:reificationMode jms:rsStandard .
_:maker jms:hasConnection _:conn .

_:conn jms:dbURL "jdbc:mysql://some.database.machine.eg/jenaDB" .
_:conn jms:dbUser "william.blake" .
_:conn jms:dbPassword "tyger, tyger" .
_:conn jms:dbType "MySQL" .
</pre>

The model-maker is specified as being a Jena RDB model-maker by
the <code>hasConnection</code>. Several models may share the same
(or similar) connections.

<p>
The connection URL specifies the database to connect to; the same 
database can support many different Jena models. The user and password 
are required to (weakly) authenticate the connection. The type is
required so that the correct database drivers can be loaded. Note
the (in-)security implications of the database password being stored
in plain text in the ModelSpec description document - these are
partly bypassed by using the <code>shared</code> property discussed
later.

<p class=note>[Consider lifting out connection as independantly specifiable
    object, so it can be shared; this then subsumes the current
	values-as-bnodes hack in ModelSpec.]
	
<p class=note>[Should contact Chris Bizer and ask him about the connections to
    databases needed for his RDB-to-graph connection.]
	
<p class=note>[Leave placeholder for BDB connections?]

<h2>an inference model</h2>

An inference model is characterised by having a reasoner specification
as well as a (base) model-maker specification. The reasoner engine is
specified by its URI (as known to the Jena ReasonerRegistry), and
additional properties, such as schemas and rules.
 
<p>Inference models require a reasoner specification as well as a
base ModelMaker. In the current ModelSpec implementation, the
reasoner only requires the URI describing the necessary inference:
other reasoner properties will be introduced in later revisions.

<pre>
_:this jms:maker _:maker .
_:this jms:reasonsWith _:reasoner .
_:reasoner jms:reasoner <http://jena.hpl.hp.com/2003/RDFSExptRuleReasoner> .
</pre>

<p class=note>[check that the URI remains correct]

<p>This is the simplest reasoner specification - just giving the URL of
the reasoner. Any other properties of the reasoner take on its usual
defaults (see [THE REASONER DOCUENTATION]). 

<p>Reasoners may be supplied with a schema or schemas as the "initial 
base" for their reasoning - for example, an RDFS reasoner may be
given an RDFS schema and do sub-type reasoning in advance of being
applied to a particular model. Schemas can be specified by giving their
URLs.

<pre>
_:reasoner jms:schemaURL <http://some.domain.xyz/RDFS/cunning> .
</pre>

If several schemas are supplied, they are merged into a single schema
to feed to the reasoner. 

<p>Similarly, a schema can be specified using a ModelSpec.
[Discussed later, when we've sorted out the unresolved issue of
 model specs that identify <i>particular</i> models.]

<pre>
_:reasoner jms:schema _:modelSpec .
</pre>

If the reasoner is a rule-based reasoner, it may be loaded with
additional rules. Those rules may be specified in the ModelSpec
description, or be identified by URL.

<pre>
_:reasoner jms:ruleSetURL <http://some.domain.xyz/RULES/straight> .
</pre>

The URL identifies a resource containing the rules, written in
an appropriate notation. Several <code>ruleSetURL</code>s may be
given; all the rules are loaded into the reasoner in no particular
order.

<p class=note>[The weasel-wording about "an appropriate notation" is to cover 
that we only have the one rule-based reasoning engine with the 
single surface syntax, wheras we ought to conver more options.
The reasoner should be in charge of parsing the rules. Also we
have only the one internal Rule class, but it's possible we should 
allow user-definable classes, or else hide Rule as a detail of
our implementation.]

<p>Similarly, 

<pre>
_:reasoner jms:ruleSet _:set .
</pre>

specifies a set of rules located elsewhere in this specification,
as properties of <code>_:set</code>. Multiple such <code>ruleSet</code>s
can be given, and they my be freely mixed with <code>ruleSetURL</code>s.

<h3>ruleSet specifications</h3>

The ruleset specifications allow different reasoner specifications to
share rule specifications (and possibly the rules themselves). The
simplest such specification is the empty one:

<pre>
_:set rdf:type jms:RuleSet .
</pre>

which may be useful as a placeholder (or a leftover from pruning
away rulesets). Additional rules may be specified inline or by
URL:

<pre>
_:set jms:hasRule "some proper rule text here" .
_:set jms:ruleSetURL <http://some.domain/RULES/example> .
</pre>

Both <code>hasRule</code> and <code>ruleSetURL</code> may be
present as often as required. Since both predicates have
domain <code>RuleSet</code>, the type declaration may be
omitted.

<p class=note>[If <code>ruleSet</code> is given range <code>RuleSet</code>,
then the type declaration is always unnecessary. I'm a bit
worried that this makes it easy to forget or mislabel a ruleset.]

<p class=note>[Again, we weasel about the notation in which the rules are
expressed. Possibly a <code>jms:ruleLanguage</code> property?]

<h2>ontology models</h2>

An OntModel specification has additional properties for specifying
the ontology language and document-manager details. For example,
using the same database connection description as our earlier example,

<pre>
_:this jms:importMaker _:conn .
_:this jms:ontLanguage "http://www.w3.org/TR/owl-features/#term_OWLLite" .
_:this jms:docManager _:DM .
_:this jms:reasonsWith _:R .

_:R jms:reasoner http://jena.hpl.hp.com/2003/RDFSExptRuleReasoner .
</pre>

specifies OntModels for the OWL Lite language, using the RDFS rule-based
reasoner. The OntModels will take their base models from the database.
The document manager has been given no specific properties, so the
default document manager will be used.

<p class=note>[More stuff needed for OntModels here]

<h1>shared specifications</h1>

By default, each time a model is constructed using a ModelSpec, new
instances of all the subcomponents of that description are created.
This is not always a wise choice, especially if those subcomponents
consume lots of space or take a long time to prepare - eg, a large
schema for a reasoner.

<p>Any sub-specification can be made <i>shared</i> by giving it the
<code>Shared</code> type:

<pre>
_:conn rdf:type jms:Shared .
</pre>

When a component of type <code>Shared</code> is requested, if there
is already a <code>Shared</code> component created from equivalent RDF,
then that component is returned rather than a new component being
created. 

<p>The method <code>ModelFactory.share( Resource r, Object o )</code>
declares that the resource <code>r</code>, which must have RDF type
<code>Shared</code>, has shared value <code>o</code>. Any modelspec
component whose description matches <code>r</code> will resolve to
the value <code>o</code>.

<p>By "equivalent RDF" we mean that the submodels reachable from 
<code>r</code> are isomorphic.

<p>So, for the database connection example, the resource 
<code>_:conn</code> can be declared shared in the user's application,
without the user's database name and password appearing in the ModelSpec.

</body>
</html>
