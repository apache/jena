/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.sparql.service.enhancer.impl;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Map;

import org.junit.jupiter.api.Test;

import org.apache.jena.graph.NodeFactory;
import org.apache.jena.query.Query;
import org.apache.jena.query.QueryFactory;
import org.apache.jena.query.Syntax;
import org.apache.jena.riot.Lang;
import org.apache.jena.riot.RDFParser;
import org.apache.jena.riot.system.PrefixMap;
import org.apache.jena.riot.system.PrefixMapFactory;
import org.apache.jena.shared.PrefixMapping;
import org.apache.jena.sparql.algebra.Algebra;
import org.apache.jena.sparql.algebra.Op;
import org.apache.jena.sparql.algebra.Table;
import org.apache.jena.sparql.algebra.op.OpService;
import org.apache.jena.sparql.core.DatasetGraph;
import org.apache.jena.sparql.core.Var;
import org.apache.jena.sparql.engine.binding.Binding;
import org.apache.jena.sparql.engine.binding.BindingFactory;
import org.apache.jena.sparql.exec.QueryExec;
import org.apache.jena.sparql.graph.GraphFactory;
import org.apache.jena.sparql.graph.PrefixMappingAdapter;
import org.apache.jena.sparql.service.enhancer.impl.BatchQueryRewriter.SubstitutionStrategy;
import org.apache.jena.sparql.service.enhancer.init.ServiceEnhancerInit;
import org.apache.jena.sparql.sse.SSE;
import org.apache.jena.sys.JenaSystem;

public class TestServiceEnhancerRewrite {
    // Ensure extensions are initialized
    static { JenaSystem.init(); }

    // @Test
    public void test01() {
        ServiceEnhancerInit.init();

        Query nonScopeRestrictedQuery = QueryFactory.create("""
            SELECT * {
              BIND("foo" AS ?foo)
              SERVICE <cache:loop+scoped:> {
                SELECT ?bar {
                  BIND(?foo AS ?bar)
                }
              }
            }
        """);

        Query scopeRestrictedQuery = QueryFactory.create("""
            SELECT * {
              BIND("foo" AS ?foo)
              SERVICE <cache:loop+scoped:> {
                SELECT ?foo ?bar {
                  BIND(?foo AS ?bar)
                }
              }
            }
        """);

        Binding b1 = MoreQueryExecUtils.evalToBinding(QueryExec.graph(GraphFactory.createDefaultGraph()).query(nonScopeRestrictedQuery).build(), ServiceEnhancerInit::wrapOptimizer);
        Binding b2 = MoreQueryExecUtils.evalToBinding(QueryExec.graph(GraphFactory.createDefaultGraph()).query(scopeRestrictedQuery).build(), ServiceEnhancerInit::wrapOptimizer);

        // FIXME Validate output and remove sysouts!
        System.out.println("TODO Finish " + this.getClass());
        System.out.println(b1);
        System.out.println(b2);

//        BatchQueryRewriter rewriter = BatchQueryRewriterBuilder.from(new OpServiceInfo(op), Var.alloc("idx"))
//                .setSequentialUnion(false)
//                .setOrderRetainingUnion(false)
//                .setOmitEndMarker(false)
//                .setSubstitutionStrategy(SubstitutionStrategy.SUBSTITUTE)
//                .build();

    }

    // @Test
    public void testFilterNotExists_01() {
//        Op op1 = Algebra.compile(QueryFactory.create(
//                """
//                SELECT * {
//                  VALUES (?this ?x) { <urn:s> <urn:p> }
//                  SERVICE <loop:> {
//                    ?this ?p ?o
//                    FILTER NOT EXISTS { ?this ?x ?y . }
//                  }
//                }
//                """, Syntax.syntaxARQ));


        OpService op = (OpService)Algebra.compile(QueryFactory.create(
            """
            SELECT * {
              SERVICE <loop:> {
                ?this ?p ?o
                FILTER NOT EXISTS { ?this ?x ?y . }
              }
            }
            """, Syntax.syntaxARQ).getQueryPattern());

        // FIXME There is a null element exception when analyzing not exists part
        //       Besides the warning message from, this might have unwanted consequences.
        //       The warning is generated by OpAsQuery which is used for the norm(alized) query.
        //       The normalized query is used in BatchQueryRewriter only for applying order by expressions
        //       - so variables in not exists shouldn't cause any problems - but still the warning should be handled.
        OpServiceInfo opServiceInfo = new OpServiceInfo(op);
        BatchQueryRewriter rewriter = BatchQueryRewriterBuilder.from(opServiceInfo, Var.alloc("idx"))
            .setSequentialUnion(false)
            .setOrderRetainingUnion(false)
            .setOmitEndMarker(false)
            .setSubstitutionStrategy(SubstitutionStrategy.SUBSTITUTE)
            .build();


          Batch<Integer, PartitionRequest<Binding>> batch = BatchImpl.forInteger();
          Var v1 = Var.alloc("this");
          Var v2 = Var.alloc("x");
          Binding b1 = BindingFactory.binding(v1, NodeFactory.createURI("urn:s1"), v2, NodeFactory.createURI("urn:p1"));
          PartitionRequest<Binding> pr1 = new PartitionRequest<>(0, b1, 0, Long.MAX_VALUE);
          batch.put(0, pr1);

          Binding b2 = BindingFactory.binding(v1, NodeFactory.createURI("urn:s2"), v2, NodeFactory.createURI("urn:p2"));
          PartitionRequest<Binding> pr2 = new PartitionRequest<>(1, b2, 0, Long.MAX_VALUE);
          batch.put(1, pr2);

          Op newOp = rewriter.rewrite(batch).getOp();

          Op expectedOp = SSE.parseOp(
          """
          (order ((asc ?idx))
            (union
              (extend ((?idx 0))
                (filter (notexists (bgp (triple <urn:s1> <urn:p1> ?/y)))
                  (bgp (triple <urn:s1> ?p ?o))))
              (union
                (extend ((?idx 1))
                  (filter (notexists (bgp (triple <urn:s2> <urn:p2> ?/y)))
                    (bgp (triple <urn:s2> ?p ?o))))
                (extend ((?idx 1000000000))
                  (table unit)))))
          """);
          String actualOpStr = newOp.toString();
          String expectedOpStr = expectedOp.toString();
          assertEquals(expectedOpStr, actualOpStr);
    }

    /**
     * This test case used to unexpectedly fail with the following error:
     *   - Binding already for ??P0 (different values)
     *
     * The reason was that the PathCompiler derived a new op with
     * additional variables. The logic of {@code SERVICE <loop:>} would then
     * emit bindings with those extra variables. These variables would then
     * clash with the lhs of the join.
     * The fix was to only project the visible variables of the original op.
     */
    @Test
    public void testLoopWithOpPath() {
        PrefixMap pm = PrefixMapFactory.create(Map.of("", "http://www.example.org/"));
        PrefixMapping pmap = new PrefixMappingAdapter(pm);

        DatasetGraph dsg = RDFParser.create()
            .fromString("""
              :a :p :b .
              :b :p :c .
              :c :p :d .
              :d :p :e .
            """).lang(Lang.TURTLE).prefixes(pm).toDatasetGraph();

        Query query = QueryFactory.create("""
            PREFIX : <http://www.example.org/>
            SELECT ?c ?e {
              :a :p/:p ?c
              SERVICE <loop:> {
                ?c :p/:p ?e
              }
            }
            """);

        // This proces an algebra with two path patterns:
        // (project (?c ?e)
        //   (join
        //      (path :a (seq :p :p) ?c)      # PathCompiler introduces ??P0
        //      (service <loop:>
        //        (path ?c (seq :p :p) ?e)))) # PathCompiler introduces ??P0 - should no longer clash.

        Table expected = SSE.parseTable("(table (vars ?c ?e) (row (?c :c) (?e :e)))", pmap);
        Table actual = QueryExec.dataset(dsg).query(query).table();
        assertEquals(expected, actual);
    }
}
