#------------------------------------------------------------------
# OWL rule set v0.3
# This rule set is designed to implement owl(f)lite using the hybrid
# rule system (mixture of forward and backward chaining). It differs
# from earlier versions by more consistently sticking to instance reasoning.
#
# Warning: This version is under active development and the moment
# and should NOT be regard as stable or usable.
#
# TODO: Replace current owl:Nothing usage by an inconsistency mechanism
#
# $Id: owl-fb-test.rules,v 1.14 2003-08-18 17:00:48 der Exp $
#------------------------------------------------------------------

#------------------------------------------------------------------
# Tabling directives
#------------------------------------------------------------------

-> table(rdf:type).
-> table(rdfs:subClassOf).
-> table(rdfs:range).
-> table(rdfs:domain).
-> table(owl:equivalentClass).

#------------------------------------------------------------------
# RDFS Axioms
#------------------------------------------------------------------

-> (rdf:type      rdfs:range rdfs:Class).
-> (rdfs:Resource  rdf:type  rdfs:Class).
-> (rdfs:Literal   rdf:type  rdfs:Class).
-> (rdf:Statement  rdf:type  rdfs:Class).
-> (rdf:nil        rdf:type  rdf:List).
-> (rdf:subject    rdf:type  rdf:Property).
-> (rdf:object     rdf:type  rdf:Property).
-> (rdf:predicate  rdf:type  rdf:Property).
-> (rdf:first      rdf:type  rdf:Property).
-> (rdf:rest       rdf:type  rdf:Property).
        
-> (rdfs:subPropertyOf rdfs:domain rdf:Property).
-> (rdfs:subClassOf rdfs:domain rdfs:Class).
-> (rdfs:domain rdfs:domain rdf:Property).
-> (rdfs:range rdfs:domain rdf:Property).
-> (rdf:subject rdfs:domain rdf:Statement).
-> (rdf:predicate rdfs:domain rdf:Statement).
-> (rdf:object rdfs:domain rdf:Statement).
-> (rdf:first rdfs:domain rdf:List).
-> (rdf:rest rdfs:domain rdf:List).

-> (rdfs:subPropertyOf rdfs:range rdf:Property).
-> (rdfs:subClassOf rdfs:range rdfs:Class).
-> (rdfs:domain rdfs:range rdfs:Class).
-> (rdfs:range rdfs:range rdfs:Class).
-> (rdf:type rdfs:range rdfs:Class).
-> (rdfs:comment rdfs:range rdfs:Literal).
-> (rdfs:label rdfs:range rdfs:Literal).
-> (rdf:rest rdfs:range rdf:List).

-> (rdf:Alt rdfs:subClassOf rdfs:Container).
-> (rdf:Bag rdfs:subClassOf rdfs:Container).
-> (rdf:Seq rdfs:subClassOf rdfs:Container).
-> (rdfs:ContainerMembershipProperty rdfs:subClassOf rdf:Property).

-> (rdfs:isDefinedBy rdfs:subPropertyOf rdfs:seeAlso).

-> (rdf:XMLLiteral rdf:type rdfs:Datatype).
-> (rdfs:Datatype rdfs:subClassOf rdfs:Class).

#------------------------------------------------------------------
# RDFS Closure rules
#------------------------------------------------------------------

# This one could be omitted since the results are not really very interesting!
#[rdf1and4: (?x ?p ?y) -> (?p rdf:type rdf:Property), (?x rdf:type rdfs:Resource), (?y rdf:type rdfs:Resource)]

[rdfs7b: (?a rdf:type rdfs:Class) -> (?a rdfs:subClassOf rdfs:Resource)] 

[rdfs2:  (?p rdfs:domain ?c) -> [(?x rdf:type ?c) <- (?x ?p ?y)] ] 
[rdfs3:  (?p rdfs:range ?c)  -> [(?y rdf:type ?c) <- (?x ?p ?y), notFunctor(?y)] ] 
[rdfs5a: (?a rdfs:subPropertyOf ?b), (?b rdfs:subPropertyOf ?c) -> (?a rdfs:subPropertyOf ?c)] 
[rdfs5b: (?a rdf:type rdf:Property) -> (?a rdfs:subPropertyOf ?a)] 
[rdfs6:  (?p rdfs:subPropertyOf ?q), notEqual(?p,?q) -> [ (?a ?q ?b) <- (?a ?p ?b)] ] 
[rdfs7:  (?a rdf:type rdfs:Class) -> (?a rdfs:subClassOf ?a)]
# omit rdfs8, derivable from rdfs9 and prototype2 - but
[rdfs9:  (?x rdfs:subClassOf ?y), notEqual(?x,?y) -> [ (?a rdf:type ?y) <- (?a rdf:type ?x)] ] 
[rdfs10: (?x rdf:type rdfs:ContainerMembershipProperty) -> (?x rdfs:subPropertyOf rdfs:member)] 

[rdfs2-partial: (?p rdfs:domain ?c) -> (?c rdf:type rdfs:Class)]
[rdfs3-partial: (?p rdfs:range ?c)  -> (?c rdf:type rdfs:Class)]

#------------------------------------------------------------------
# RDFS iff extensions needed for OWL
#------------------------------------------------------------------

[rdfs2a: (?x rdfs:domain ?z) <- bound(?x), (?x rdfs:domain ?y), (?y rdfs:subClassOf ?z) ]
[rdfs2a: (?x rdfs:domain ?z) <- unbound(?x), (?y rdfs:subClassOf ?z), (?x rdfs:domain ?y) ]
[rdfs3a: (?x rdfs:range  ?z) <- bound(?x), (?x rdfs:range  ?y), (?y rdfs:subClassOf ?z) ]
[rdfs3a: (?x rdfs:range  ?z) <- unbound(?x), (?y rdfs:subClassOf ?z), (?x rdfs:range  ?y) ]

[rdfs12a: (rdf:type rdfs:subPropertyOf ?z), (?z rdfs:domain ?y) -> (rdfs:Resource rdfs:subClassOf ?y)]
[rdfs12a: (rdfs:subClassOf rdfs:subPropertyOf ?z), (?z rdfs:domain ?y) -> (rdfs:Class rdfs:subClassOf ?y)]
[rdfs12a: (rdfs:subPropertyOf rdfs:subPropertyOf ?z), (?z rdfs:domain ?y) -> (rdf:Property rdfs:subClassOf ?y)]

[rdfs12b: (rdfs:subClassOf rdfs:subPropertyOf ?z), (?z rdfs:range ?y) -> (rdfs:Class rdfs:subClassOf ?y)]
[rdfs12b: (rdfs:subPropertyOf rdfs:subPropertyOf ?z), (?z rdfs:range ?y) -> (rdf:Property rdfs:subClassOf ?y)]

#------------------------------------------------------------------
# OWL axioms
#------------------------------------------------------------------

-> (rdf:first rdf:type owl:FunctionalProperty).
-> (rdf:rest rdf:type owl:FunctionalProperty).

-> (rdfs:domain owl:SymmetricProperty owl:ObjectProperty).
-> (rdfs:domain owl:TransitiveProperty owl:ObjectProperty).
-> (rdfs:domain owl:InverseFunctionalProperty owl:ObjectProperty).

-> (rdfs:range owl:ObjectProperty owl:Thing).
-> (rdfs:domain owl:ObjectProperty owl:Thing).
-> (rdfs:domain owl:DatatypeProperty owl:Thing).

-> (owl:Class rdfs:subClassOf rdfs:Class).
-> (owl:Restriction rdfs:subClassOf owl:Class).

# The distinction between rdfs and owl class with disappear. 
# Adding this in introduces rather a lot of duplicate reasoning paths
# which slow things down for no purpose.
#-> (rdfs:Class rdfs:subClassOf owl:Class).

-> (owl:Thing rdf:type owl:Class).

# These might need to be pre-expanded in the initial rule set
-> (owl:equivalentProperty rdf:type owl:SymmetricProperty).
-> (owl:equivalentProperty rdf:type owl:TransitiveProperty).
-> (owl:equivalentClass rdf:type owl:SymmetricProperty).
-> (owl:equivalentClass rdf:type owl:TransitiveProperty).
-> (owl:sameAs rdf:type owl:SymmetricProperty).
-> (owl:sameIndividualAs rdf:type owl:SymmetricProperty).
-> (owl:sameIndividualAs rdf:type owl:TransitiveProperty).
-> (owl:sameIndividualAs owl:equivalentProperty owl:sameAs).
-> (owl:differentFrom rdf:type owl:SymmetricProperty).
-> (owl:disjointWith rdf:type owl:SymmetricProperty).

-> (owl:intersectionOf rdfs:domain owl:Class).

#------------------------------------------------------------------
# OWL Rules
#------------------------------------------------------------------

[thing1: (?C rdf:type owl:Class) -> (?C rdfs:subClassOf owl:Thing)]

#------------------------------------------------------------------
# Prototype rules to convert instance reasoning to class subsumption checking
#------------------------------------------------------------------

[earlyTypeProp1: (?C rdf:type owl:Restriction) -> (?C rdf:type owl:Class) ]

[earlyTypeProp2: (?C owl:intersectionOf ?X) -> (?C rdf:type owl:Class) ]

[prototype1: (?c rdf:type owl:Class), noValue(?c, rb:prototype), makeTemp(?t)
  	    				-> (?c rb:prototype ?t), (?t rdf:type ?c) ]
    
[prototype2: (?c rb:prototype ?p) ->
                [prototype2b: (?c rdfs:subClassOf ?d) <- (?p rdf:type ?d)] ]                

#------------------------------------------------------------------
# Identify restriction assertions
#------------------------------------------------------------------

[restriction1: (?C rdf:type owl:Restriction), (?C owl:onProperty ?P), (?C owl:someValuesFrom ?D)
						-> (?C owl:equivalentClass some(?P, ?D))]
		
[restriction2: (?C rdf:type owl:Restriction), (?C owl:onProperty ?P), (?C owl:allValuesFrom ?D)
						-> (?C owl:equivalentClass all(?P, ?D))]
		
[restriction3: (?C rdf:type owl:Restriction), (?C owl:onProperty ?P), (?C owl:minCardinality ?X)
						-> (?C owl:equivalentClass min(?P, ?X))]
		
[restriction4: (?C rdf:type owl:Restriction), (?C owl:onProperty ?P), (?C owl:maxCardinality ?X)
						-> (?C owl:equivalentClass max(?P, ?X))]
		
[restriction5: (?C rdf:type owl:Restriction), (?C owl:onProperty ?P), (?C owl:cardinality ?X)
						-> (?C owl:equivalentClass card(?P, ?X)), 
						   (?C rdfs:subClassOf min(?P, ?X)), 
						   (?C rdfs:subClassOf max(?P, ?X)) ]
		
[restriction6: (?C rdfs:subClassOf min(?P, ?X)), (?C rdfs:subClassOf max(?P, ?X)) 
       					-> (?C rdfs:subClassOf card(?P, ?X))]

# Could limit the work done here by inserting an isFunctor guard?
[restrictionPropagate1: (?C owl:equivalentClass ?R), (?D rdfs:subClassOf ?C) 
                                -> (?D rdfs:subClassOf ?R) ]
[restrictionPropagate2: (?C owl:equivalentClass ?R), (?D owl:equivalentClass ?C) 
                                -> (?D owl:equivalentClass ?R) ]

# Needed for the case where ?R is a restriction literal 
# and so does not appear in the subject position
[restrictionSubclass1: (?D owl:equivalentClass ?R), isFunctor(?R) ->
       [restrictionSubclass1b: (?X rdf:type ?D) <- (?X rdf:type ?R)] ]
       
[restrictionSubclass2: (?D owl:equivalentClass ?R), isFunctor(?R) ->
       [restrictionSubclass2b: (?X rdf:type ?R) <- (?X rdf:type ?D)] ]
       
# Temp trial - might replace above       
#[restrictionSubclass1: (?D owl:equivalentClass ?R), isFunctor(?R) , (?X rdf:type ?R) -> (?X rdf:type ?D)]
#[restrictionSubclass2: (?D owl:equivalentClass ?R), isFunctor(?R) , (?X rdf:type ?D) -> (?X rdf:type ?R)]
						
#------------------------------------------------------------------
# min cardinality
#------------------------------------------------------------------

[min: (?C rdfs:subClassOf min(?P, 1)) -> table(?P),
    [min1b: (?X ?P ?T) <- (?X rdf:type ?C), noValue(?X, ?P), makeInstance(?X, ?P, ?T)] 
    ]

[minRec: (?C owl:equivalentClass min(?P, 1)), notEqual(?P, rdf:type) -> table(?P),
    [min2b: (?X rdf:type ?C) <- (?X ?P ?Y)] ]

[restriction-inter-MnS: (?P rdfs:range ?D), (?C rdfs:subClassOf min(?P, 1)) 
						-> (?C rdfs:subClassOf some(?P, ?D)) ]
        
#------------------------------------------------------------------
# max cardinality 1
#------------------------------------------------------------------

[max1: (?C rdfs:subClassOf max(?P, 1)) -> table(?P),
    [max1b: (?Y1 owl:sameIndividualAs ?Y2) <- bound(?Y1),   (?X ?P ?Y1), (?X rdf:type ?C), (?X ?P ?Y2), notEqual(?Y1, ?Y2)]
    [max1b: (?Y1 owl:sameIndividualAs ?Y2) <- unbound(?Y1), (?X ?P ?Y2), (?X rdf:type ?C), (?X ?P ?Y1), notEqual(?Y1, ?Y2)]
    ]
    
[maxRec: (?C owl:equivalentClass max(?P, 1)), (?P rdf:type owl:FunctionalProperty) ->
    [ (?X rdf:type ?C) <- (?X rdf:type owl:Thing)] ]

#------------------------------------------------------------------
# max cardinality 0
#------------------------------------------------------------------

[max2: (?C rdfs:subClassOf max(?P, 0)) -> table(?P),
    [max2b: (?X rdf:type owl:Nothing) <- (?X rdf:type ?C), (?X ?P ?Y) ] ]

# For completeness this requires iff version of rdfs:domain working forwards which it does not just now
[maxRec2: (?C owl:equivalentClass max(?P, 0)), (?P rdfs:domain ?D), (?E owl:disjointWith ?D)
	-> (?E owl:equivalentClass ?C)]
	
[cardRec1: (?C owl:equivalentClass card(?P, 0)), (?P rdfs:domain ?D), (?E owl:disjointWith ?D)
	-> (?E owl:equivalentClass ?C)]
	
[cardRec3: (?C owl:equivalentClass card(?P, 0)) -> table(?P),
	[cardRec2b: (?X rdf:type ?C) <- (?X rdf:type max(?P, 0))] ]

#------------------------------------------------------------------
# cardinality 1
#------------------------------------------------------------------

[restriction-inter-CFP: (?C owl:equivalentClass card(?P, 1)), (?P rdf:type owl:FunctionalProperty) ->
     (?C owl:equivalentClass min(?P, 1)) ]

[cardRec2: (?C owl:equivalentClass card(?P, 1)) -> table(?P),
	[cardRec2b: (?X rdf:type ?C) <- (?X rdf:type min(P, 1)), (?X rdf:type max(P, 1)) ] ]

#------------------------------------------------------------------
# someValuesFrom
#------------------------------------------------------------------

# Are all the guards still necessary?
[some1: (?C rdfs:subClassOf some(?P, ?D)), notEqual(?P, owl:sameIndividualAs),
					notEqual(?C, owl:Class), notEqual(?C, rdfs:Class), 
					notEqual(?P, rdfs:subClassOf), notEqual(?P, rdfs:subPropertyOf), 
					notEqual(?P, owl:equivalentProperty), notEqual(?P, owl:equivalentClass),
   -> table(?P),
    [some1b: (?X ?P ?T) <- (?X rdf:type ?C),  noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ] 
    [some1b: (?T rdf:type ?D) <- (?X rdf:type ?C), makeInstance(?X, ?P, ?D, ?T) ] 
    
#    [some1b: (?X ?P ?T) <- (?X rdf:type ?C), unbound(?T), noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ] 
#    [some1b: (?X ?P ?T) <- (?X rdf:type ?C), bound(?T), makeInstance(?X, ?P, ?D, ?T) ] 
#    [some1b: (?T rdf:type ?D) <- (?X rdf:type ?C), unbound(?T), noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ] 
#    [some1b: (?T rdf:type ?D) <- (?X rdf:type ?C), bound(?T), makeInstance(?X, ?P, ?D, ?T) ] 
    ]
    
[someRec: (?C owl:equivalentClass some(?P, ?D)), (?P rdfs:range ?D) -> table(?P),
     [someRecb: (?X rdf:type ?C) <- (?X ?P ?A) ] ]
    
#------------------------------------------------------------------
# allValuesFrom
#------------------------------------------------------------------

[all1: (?C rdfs:subClassOf all(?P, ?D)), notEqual(?P, rdf:type), notEqual(?C, ?D) -> table(?P),
		[all1b: (?Y rdf:type ?D) <- (?X ?P ?Y), (?X rdf:type ?C) ] ]

[allRec1: (?C rdfs:subClassOf max(?P, 1)), (?C rdfs:subClassOf some(?P, ?D))
						-> (?C rdfs:subClassOf all(?P, ?D)) ]

[allRec2: (?P rdf:type owl:FunctionalProperty), (?C rdfs:subClassOf some(?P, ?C))
						 -> (?C rdfs:subClassOf all(?P, ?C)) ]
    
[allRec3: (?C owl:equivalentClass all(?P, ?D)), (?P rdfs:range ?D) -> table(?P),
    [ (?X rdf:type ?C) <- (?X rdf:type owl:Thing)] ]

[restriction-inter-RA-T: (?P rdfs:range ?C), (?D owl:equivalentClass all(?P, ?C)) 
						-> (owl:Thing rdfs:subClassOf ?D) ]
						
[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf all(?P, ?C)) 
						-> (?P rdfs:range ?C), (?P rdf:type owl:ObjectProperty) ]

# This version looks strange but we are experimenting with droping the direct
# subclass transitive closure and inferring from prototypes, but that is being
# done backwards for forwards subclass relationships are handled as special cases
#[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf ?D) (?D owl:equivalentClass all(?P, ?C)) 
#						-> (?P rdfs:range ?C), (?P rdf:type owl:ObjectProperty) ]
    
#------------------------------------------------------------------
# Disjointness
#------------------------------------------------------------------

[distinct1: (?C owl:disjointWith ?D), (?X rdf:type ?C), (?Y rdf:type ?D) 
						-> (?X owl:differentFrom ?Y) ]

# Exploding the pairwise assertions is simply done procedurally here.
# This is better handled by a dedicated equality reasoner any.
[distinct2: (?w owl:distinctMembers ?L) -> assertDisjointPairs(?L) ]

# Example version of validation rule, more TBD
[validation1: (?X rdf:type owl:Nothing) <- (?X owl:differentFrom ?Y), (?X owl:sameIndividualAs ?Y) ]

#------------------------------------------------------------------
# Class equality
#------------------------------------------------------------------

# equivalentClass
[equivalentClass1: (?P owl:equivalentClass ?Q) 
						-> (?P rdfs:subClassOf ?Q), (?Q rdfs:subClassOf ?P) ]
						
[equivalentClass2: (?P owl:equivalentClass ?Q) <-  (?P rdfs:subClassOf ?Q), (?Q rdfs:subClassOf ?P) ]
						
[equivalentClass3: (?P owl:sameAs ?Q), (?P rdf:type rdfs:Class), (?Q rdf:type rdfs:Class) 
						-> (?P owl:equivalentClass ?Q) ]
						
#------------------------------------------------------------------
# Instance equality
#------------------------------------------------------------------

# sameIndividualAs

[sameIndividualAs1: (?P rdf:type owl:FunctionalProperty) -> table(?P),
      [sameIndividualAs1b: (?B owl:sameIndividualAs ?C) <- unbound(?C), (?A ?P ?B), (?A ?P ?C) ] 
      [sameIndividualAs1b: (?B owl:sameIndividualAs ?C) <-   bound(?C), (?A ?P ?C), (?A ?P ?B) ] 
      ]
                    
[sameIndividualAs2: (?P rdf:type owl:InverseFunctionalProperty) -> table(?P),
      [sameIndividualAs2b: (?A owl:sameIndividualAs ?C) <- unbound(?C), (?A ?P ?B), (?C ?P ?B) ] 
      [sameIndividualAs2b: (?A owl:sameIndividualAs ?C) <-   bound(?C), (?C ?P ?B), (?A ?P ?B) ] 
      ]
      
[sameIndividualAs3: (?X owl:sameAs ?Y), (?X rdf:type owl:Thing), (?Y rdf:type owl:Thing) 
                    -> (?X owl:sameIndividualAs ?Y) ]                    

[sameIndividualAs4a: (?Y ?P ?V) <- unbound(?V), (?X owl:sameIndividualAs ?Y), notEqual(?X,?Y), (?X ?P ?V) ]
[sameIndividualAs4c: (?Y ?P ?V) <- bound(?V), (?X ?P ?V), notEqual(?X,?Y), (?X owl:sameIndividualAs ?Y)  ]
[sameIndividualAs5a: (?V ?P ?Y) <- unbound(?V), (?X owl:sameIndividualAs ?Y), notEqual(?X,?Y), (?V ?P ?X)  ]
[sameIndividualAs5c: (?V ?P ?Y) <- bound(?V), (?V ?P ?X), notEqual(?X,?Y), (?X owl:sameIndividualAs ?Y) ]

[sameIndividualAs6: (?X rdf:type owl:Thing) <- (?X owl:sameIndividualAs ?Y) ]
#[sameIndividualAs6: (?Y rdf:type owl:Thing) <- (?X owl:sameIndividualAs ?Y) ]

#------------------------------------------------------------------
# Property rules
#------------------------------------------------------------------

# EquivalentProperty 

[equivalentProperty1: (?P owl:equivalentProperty ?Q) 
						-> (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P) ]
						
[equivalentProperty2: (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P) 
						-> (?P owl:equivalentProperty ?Q) ]
						
[equivalentProperty3: (?P owl:sameAs ?Q), (?P rdf:type rdfs:Property), (?Q rdf:type rdfs:Property) 
						-> (?P owl:equivalentProperty ?Q) ]

# SymmetricProperty

[symmetricProperty1: (?P rdf:type owl:SymmetricProperty) -> table(?P),
                     [symmetricProperty1b: (?X ?P ?Y) <- (?Y ?P ?X)] ]


# inverseOf
[inverseOf1: (?P owl:inverseOf ?Q) -> (?Q owl:inverseOf ?P) ]

[inverseOf2: (?P owl:inverseOf ?Q) -> table(?P), table(?Q), [inverseOf2b: (?X ?P ?Y) <- (?Y ?Q ?X)] ]

[inverseOf3: (?P owl:inverseOf ?Q), (?P rdf:type owl:FunctionalProperty) 
						-> (?Q rdf:type owl:InverseFunctionalProperty) ]
		
[inverseOf4: (?P owl:inverseOf ?Q), (?P rdf:type owl:InverseFunctionalProperty) 
						-> (?Q rdf:type owl:FunctionalProperty) ]

# TransitiveProperty

[transitiveProperty1: (?P rdf:type owl:TransitiveProperty) -> table(?P),
#			[transitiveProperty1b:  (?A ?P ?C) <- (?A ?P ?B), (?B ?P ?C)] ]
			[transitiveProperty1b:  (?A ?P ?C) <- bound (?C), (?B ?P ?C), (?A ?P ?B)] 
			[transitiveProperty1b:  (?A ?P ?C) <- unbound (?C), (?A ?P ?B) (?B ?P ?C)] 
			]
			