==== ARQ ToDo

++ ** Document "stages"
++ ** Document "update API"
++ Algebra building src-examples 
++ javadoc-all in the build = 5M of zip.
++ Reorder documentation - intro, SPARQL, extensions.
-----

+ OpOrder to take an ExprList
+ ExprList writing an LJ

+ Aggregates: QueryIterGroup
  Parsing : 
     SELECT list is expressions always 
       A  list or pairs (name expr)
       Make type safe in the Query class.
     Phase 2 detects inconsistences 

+ SELECT expressions [DONE - testing needed]
  Document 
  Prefix writing (drop prefix form altogether now we have the algebra?)
  Alt syntax: EXPR(expr,?var)  (expr[,?var]) (expr):?var
    [ ?x+?y , ?z ]
    (?z := ?x+?y)
  

+ Optimizer 
  
+ Check the better code in QueryIterTriplePattern.TripleMapper 
  Still needs to delay the binding allocation.  
         
+ DateTime arithmetic and durations
  http://www.w3.org/TR/xpath-functions/#dateTime-arithmetic

+ Quads - independent quads?  Or retain blocking structure?

+ Remote update over HTTP

+ testing QE/ref and QE/main in the same run
  ?? use a factory list, including tests with no recorded results.
  ?? Could simply factory to have .create() return null for "no".

+ Initial binding for UpdateRequest

== Core

+ FmtUtils and WriterTriple/Node/...
  NodeToLabel maps.

+ ResultsFormat (output)vs ResultSetFormat (input)
  ResultSetFormatter.oopput as SSE
  ResultSetFactory input as SSE
  rset handler boolean and result set XML forms together => sSPARQLResults.

+ What is "OpDatasetNames" nowadays?
	A table?  unnecessary?
+ Revisit arq.cmd.QueryUtils for printing.

+ Alternative indexes
  LARQ idea - extracted.  Object ==> node/subject
  
+ REDUCED tests :-(

+ Commands
  + qtest to use modules (and qexpr)
    ModVersion
  + qparse to test op output

+ DatasetImpl and DataSourceImpl 
    Revisit.
      
== Algebra

+ OpWalker - only used for getting vars, and that needs to truncate a walk.
+ Left join as "join union diff"
+ Table equals (with and without order)
  
== LARQ

+ LARQ assembler

+ Implement IndexBuilderLiter.unindexStatement

+ LARQ Doc internals
  Fields: index, lex/lang/datatype, uri, bnode

== Documentation

+ list handling as a specific page.
  + Internals
  	Query iterators
  	Bindings

+ Writing filter functions [Done]
+ Writing property functions

+ Document making and using datasets
+ Location-mapping and FROM/FROM NAMED
  
== Other

+ XML results: process xml:lang on other elements than just <literal>
  Documentation for XML result set processing
