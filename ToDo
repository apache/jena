==== ARQ ToDo

++ ** Document "stages"

-----

Improvements - are these measurable?
  If a stage generates no new bindings, don't allocation a BindingMap unnecessarility.

== Core

Tidying up: 
+ QueryEngineFactory
    QueryEngineOpFactory to adapter QueryEngineOpBase subclasses?
    QueryEngineOpBase adapter to something.
+ Remove QueryExecutionGraphFactory
+ Remove QueryExecutionGraph - it's OpExec now.
    Registry for OpExec level.

+ Binding - becomes BindingBase.
  Add "Binding Binding.add(var, value)" for switching to a Binding Map IIF there is a binding added.
  Check BindingMap uses?
    

+ qexec : no datasets evaluation [done with a dummy DSG]
+ What is "OpDatasetNames" nowadays?
	A table?  unnecessary?
+ Revisit arq.cmd.QueryUtils for printing.

+ Test algebra using BuilderTable etc.
  test scripts : (test (data) (expression) (table))

+ A result set is like a table except with (cols)
  ResultsFormat.FMT_SSE!

+ Alternative indexes
  LARQ idea - extracted.  Object ==> node/subject
  
+ REDUCED tests :-(

+ Serilization: 
    redo "prefix" to be SSE compatible.

+ Property function to property path expression

+ Non-distinguished variable removal.
   StageBuilder - strict place
   In a project (or pseudo project) - does it once.
      Need test case : { _:a :p ?v. ?v :splitIRI (?ns ?ln) . _a :p ?w } 
      
+ testing QE1 and QE2 and QE3 in the same test run

+ Commands
  + qtest to use modules (and qexpr)
    ModVersion
  + qexec tidy/integration with qparse/query : need an "op" level.
    Maybe QueryExecutionOp interface.

== Algebra

+ OpWalker  - only used for getting vars, and that needs to truncate a walk.
+ OpExt - is this still workable?
+ Tests
+ Complete operators
	Grouping
    Intersection, diff, exists filter and subqueries.
+ Left join as "join union diff"
+ Table equals (with and without order)
+ Binding equals

  
== SSE
  Tables as Ops.
  Builder tidying and testing
  
  ItemLists : cons cells?!
    Why?  Why not?

  Expr: (exists (pattern ...))
  
  (group (vars) aggregate)
  
  Assignment:
  (assign ((?x expr) (?y expr)) --  (:= ?x expr) [is this SELECT/project?]
     (project ...))
     (project (?x ?y (?z expr)) ...)

+ Prefix writing.

== LARQ

+ LARQ assembler

+ LARQ Doc internals
  Fields: index, lex/lang/datatype, uri, bnode

== Documentation

+ list handling as a specific page.
  + Internals
  	Query iterators
  	Bindings

+ Writing filter functions [Done]
+ Writing property functions

+ Document making and using datasets
+ Location-mapping and FROM/FROM NAMED
  
== Core

+ XML results: process xml:lang on other elements than just <literal>
  Documentation for XML result set processing
